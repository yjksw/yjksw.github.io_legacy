---
layout: post
cover: 'assets/images/cover6.jpg'
navigation: True
use_math: True
title: "JPA를 통한 CRUD"
date: 2020-09-23 10:18:00
tags: backend
subclass: 'post tag-backend'
logo: 'assets/images/ghost.png'
author: yj
categories: yj
---
<br>
### Repository 생성

- Repository: 따로 쿼리문을 작성하지 않아도 객체에 대한 database 관리를 할 수 있도록 해주는 것이다.

@Autowired 라는 annotation 을 통해서 Dependency Injection (DI) 를 실행 한다. 

- Spring 에서 가장 큰 장점으로, 객체를 new 명령어를 써서 생성하지 않아도 @Autowired 라는 키워드를 찾아서 주입을 시켜주는 기능을 한다.

본래는 create() 안에 다음과 같은 query문으로 실행을 시켜야 했을 것이다. 

```java
String sql = insert into user(%s, %s, %d) value (account, email, age);
```

하지만 JPA의 장점은 이러한 쿼리문이 아니라 object를 가지고 database를 관리할 수 있도록 해주는 것이다. 

### [CREATE] 실습: User라는 객체를 Database에 생성

생성한 UserRepository Class 안에 **CRUD** 메소드가 각각 있다. 

create() 안에서 Repository 가 작동하도록 해보자. 

```java
@Test
public void create() {
	User user = new User(); 
  //user.setId(); Auto-Increment 이기 때문에 직접 set하지 않음. 
  user.setEmail();
  user.setAccount();
  user.setPhoneNumber();
  user.setCreateAt();
  user.setCreatedBy();
	//괄호 안에 값들 넣어주기 
	//NN 인 것들은 반드시 값을 지정해주어야 함. 

	User newUser = userRepository.save(user);
	//save 메소드는 User를 Database에 넘기고 새로운 User 라는 객체를 return 함. 
	//이 newUser 에는 지정하지 않은 ID도 알아서 지정이 되어 있음.
	
	System.out.println("newuser: " + newUser);
	//깔끔하게 출력이 되는데, @Data에 의해 Lombok에서 toString이라는 메소드를 제공하기 때문. 
}
```

 왜 User 객체에 대해서는 위에서처럼 DI 해주지 않을까 ?

→ User 객체는 정보 마다 새롭게 생성이 되어야 하는 객체. 

→ 위에서 사용하는 UserRepository 와 같은 경우는 하나만 생성해서 모든 UserRepository에 대해서 모두 Autowired 시킬 것이기 때문이다. 

**이 Hibernate의 장점이 객체를 가지고 Database에 insert를 칠 수 있는 것!** 

#### 실제 SQL문을 확인하고 싶을 때:

Resource > [application.properties](http://application.properties) > 다음 문장을 추가

spring.jpa.show-sql=true

다음과 같이 위에 Hibernate 이후에 sql문이 함께 출력된다. 

![image](https://user-images.githubusercontent.com/63405904/114411190-ee6f7f80-9be6-11eb-8833-34c671277434.png)

### [READ] 실습: Database에서 정보를 읽기

UserRepository를 통해서 READ를 할 것이다. 

기본적으로 JPA userRepository에서 READ 관련 기능 들을 제공함 → find ... 등등

```java
@Test
public void read() {
	Optional<User> user = userRepository.findById(2L); 
	//return 타입이 optional임.
	//ID 2 번에 대해서 타입이 Long 이므로 2L 이라고 작성함.

  user.ifPresent(selectUser-> { //Optional 타입 이므로 존재한다면, 
	  System.out.println("user: "+selectUser); //출력하겠다 라는 의미.
		System.out.println("email: "+selectUser.getEmail());
	});

}

```

- 나중에 REST와 CRUD를 연결시켜주면, url 파라미터로 들어온 ID 값에 대한 정보를 받고 return 해줄 수 있다.

```java
//예시
public User read(@RequestParam Long id) {
	Optional<User> user = userRepository.findById(id); 

  user.ifPresent(selectUser-> { //Optional 타입 이므로 존재한다면, 
	  System.out.println("user: "+selectUser); //출력하겠다 라는 의미.
		System.out.println("email: "+selectUser.getEmail());
	});

	return user.get();
} 
```

### [UPDATE] 실습: Database에서 정보를 읽어서 업데이트하기

우선 특정 정보를 가지고 온 후에 → 업데이트 진행하는 순서. 

```java
@Test
public void update() {
	Optional<User> user = userRepository.findById(2L);

  user.ifPresent(selectUser-> {
	  selectUser.setAccount("pppp");
    selectUser.setUpdatedAt(LocalDateTime.now());
    selectUser.setUpdatedBy("update method()");
			
		//여기서 다시한번 Select를 한다. 
		//sql문을 확인해보면 따라서 select를 총2번 진행한 후에, save 한다. 
    userRepository.save(selectUser); //update 후에 반드시 save 해야 함.
  });
}
```

** 이전에 CREATE 할 때는 save()를 했을 때, 새로운 user가 나왔는데 어떻게 JPA는 CREATE와 UPDATE를 구분할까?

- 이미 있는 id에 대해서 존재하는지 체크하고 존재 여부에 따라서 구분함.
- JPA에서 동작할 때, 우선 select → update하는데 바꾸지 않은 값들도 기존의 값들도 다시 한번 업데이트를 진행함. (sql 문으로 확인 가능)

### [DELETE] 실습: Database에서 정보 삭제

DELETE 또한 마찬가지로, id 를 받아서 특정 정보에 대해서 지워야 하는 것이다. 

즉, 삭제 대상에 대한 정보가 들어와야 함.(REST와 연동 시 정보를 받아와야 함)

```java
@Test
public void delete() {
	Optional<User> user = userRepository.findById(2L);

	Assert.assertTrue(user.isPresent()); //반드시 true 임을 확인하는 Test 코드 
        
  user.ifPresent(selectUser-> {
	  userRepository.delete(selectUser);
  });

  Optional<User> deleteUser = userRepository.findById(2L);
	
	//이 코드는 사용 가능하나, 적합한 test 코드는 아님. 
	/*if(deleteUser.isPresent()){
		  System.out.println("데이터 존재: " + deleteUser.get());
  } else {
      System.out.println("데이터 삭제");
  }*/

	Assert.assertFalse(user.isPresent()); // 반드시 false 여야 한다는 것을 확인하는 Test 코드
}
```

Test 를 실행할 때마다 데이터베이스의 요소들이 없어지면 안될 대는 @Transactional 이라는 annotation을 달아서 실행되는 것은 test 하지만 데이터베이스에서 값의 변화는 없도록 하자.