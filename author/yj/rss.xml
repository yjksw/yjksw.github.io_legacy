<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>yjksw.github.io/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[머신러닝]나이브 베이즈 분류기(Naive Bayes Classifier)</title>
	  <link>//naivebayes</link>
	  <author></author>
	  <pubDate>2021-02-26T10:18:00+00:00</pubDate>
	  <guid>//naivebayes</guid>
	  <description><![CDATA[
	     <p>강남의 어느 검색 솔루션 기업에서 인턴한지 어연 4주차가 지나간다. 중간지점을 지나가면서 한 것을 정리할 겸 나이브베이즈 문서 분류기 구현과 이론에 대해서 정리해 보려고 한다. 최대한 쉽게!!</p>

<p>나이브 베이즈 분류기는 베이즈 정리(Bayes’ theorem)을 사용한 분류
알고리즘이다. 이것은 전통적으로 텍스트 분류를 하는 분류기로 인공지능의
기능을 기학적으로 올려준 인공 신경망 알고리즘은 아니지만 머신 러닝의
중요한 알고리즘 중 하나로 꽤 좋은 성능을 보인다. 나이브 베이즈
분류기에서 사용하는 베이즈 정리는 무엇일까?</p>

<p><a href="#%EB%B2%A0%EC%9D%B4%EC%A6%88%EC%9D%98-%EC%A0%95%EB%A6%ACbayes-theorem%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%B6%84%EB%A5%98-%EA%B8%B0%EB%B2%95"></a></p>

<p>베이즈의 정리(Bayes’ theorem)를 사용한 분류 기법</p>

<p>베이즈 정리는 조건부 확률을 계산하는 방법 중 하나이다. 다음과 같이
표현할 수 있다.</p>

<ul>
  <li><strong><em>P(A)</em></strong>: 사전확률(Prior). 사건 B가 발생하기 전 A가 가지고 있던
확률</li>
  <li><strong><em>P(B)</em></strong>: 정규화 상수(normalizing constant). B가 일어날 확률</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>***P(B</td>
          <td>A)***: 가능도(likelihood). A가 발생한 경우 B가 일어날 확률</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>***P(A</td>
          <td>B)***: 사후확률(Posterior). B가 발생한 후 A가 일어날 확률</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<table>
  <tbody>
    <tr>
      <td>이 때 ***P(A</td>
      <td>B)***를 구하려면, 다음과 같은 수식을 사용한다.</td>
    </tr>
  </tbody>
</table>

<p>P(A∣B)=P(B∣A)P(A)P(B)P(A|B) = \frac {P(B|A)P(A)}
{P(B)}P(A∣B)=P(B)P(B∣A)P(A)​</p>

<p>주로 나이브 베이즈 분류기법을 설명할 때 스팸 메일 분류기를 예를 들어서
설명한다.</p>

<p><a href="#%EB%82%98%EC%9D%B4%EB%B8%8C-%EB%B2%A0%EC%9D%B4%EC%A6%88%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%8A%A4%ED%8C%B8-%EB%B6%84%EB%A5%98%EA%B8%B0"></a></p>

<p>나이브 베이즈를 활용한 스팸 분류기</p>

<p>어떤 문서 D에 대하여 해당 문서가 스팸(S)클래스에 속하는지
일반(!S)클래스에 속하는지 분류할 때 나이브 베이즈 분류 알고리즘을
사용한다고 하자. 그리고 이미 각기 다른 단어들에 대해서 해당 단어가
스팸일 확률과 일반일 확률에 대한 데이터가 이미 확보되어 있다고 가정한다.
한번 기호로 살펴보자. 우리가 가지고 있는 데이터는 다음 두개와 같다.
다음은 각각 “Sale이라는 단어는 60%의 확률로 스팸메일에서 발견되고, 30%의
확률로 일반메일에 발견된다.”라는 정보를 가지고 있는 것이다.</p>

<table>
  <tbody>
    <tr>
      <td>P(′Sale′∣S),P(′Sale′∣!S)P(‘Sale’</td>
      <td>S),</td>
    </tr>
    <tr>
      <td>P(‘Sale’</td>
      <td>!S)P(′Sale′∣S),P(′Sale′∣!S)</td>
    </tr>
  </tbody>
</table>

<p>데이터를 수 만개의 단어들에 대한 위의 데이터를 활용해서 결국 풀고 싶은
문제는 P(S∣D)P(S|D)P(S∣D)와 P(!S∣D)P(!S|D)P(!S∣D)이다. 다음 두 확률을
구한 다음 확률이 더 큰 클래스에 해당 문서가 속한다고 결론을 내린다.
P(S∣D)P(S|D)P(S∣D)는 문서 DDD가 주어졌다는 가정하에 해당 문서가 스팸일
조건부 확률을 나타낸다. 반대로 P(!S∣D)P(!S|D)P(!S∣D)는 문서 DDD가
주어졌다는 가정하에 해당 문서가 스팸이 아닐 조건부 확률을 나타낸다. 해당
문서를 어떤 클래스에 속하는지 분류하려면 먼저 문서에서 feature를
추출해야 한다. 추출된 feature들이 어떤 규칙에 의한 키워드 단어들이라고
할 때, 베이즈 정리는 특징벡터x=(x1,x2,…,xn)x=(x1, x2, …,
xn)x=(x1,x2,…,xn)의 요소들이 모두 <strong>조건부 독립</strong>이라는 가정을 한다.
즉, 각 단어들이 서로 미치는 확률에 있어서 연관이 없다고 가정하는 것이다.
(이 부분에서 ‘Naive(순진한) ‘라는 이름이 붙는다. 실제로는 모두
독립적이지 않고 동등하지 않은데 이렇게 간주해버리는 순진함을 가지고
있다.) 이때 해당 특징벡터 xxx에 대한 클래스 SSS에 속할 확률은 다음과
같다.</p>

<p>P(S∣x1,x2,…,xn)=P(x1,x2,…,xn)P(S)P(x1,x2,…,xn)P(S|x1,x2,…,xn)=\frac
{P(x1,x2,…,xn)P(S)}{P(x1,x2,…,xn)}P(S∣x1,x2,…,xn)=P(x1,x2,…,xn)P(x1,x2,…,xn)P(S)​</p>

<p>앞에서 언급했듯이 각 feature의 요소들은 조건부 독립이기 때문에 다음과
같이 바꿔 쓸 수 있다.</p>

<table>
  <tbody>
    <tr>
      <td>P(S∣x1,x2,…,xn)=P(x1∣S)P(x2∣S)…P(xn∣S)P(S)P(x1)P(x2)…P(xn)P(S</td>
      <td>x1,x2,…,xn)=\frac</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>{P(x1</td>
      <td>S)P(x2</td>
      <td>S)…P(xn</td>
      <td>S)P(S)}{P(x1)P(x2)…P(xn)}P(S∣x1,x2,…,xn)=P(x1)P(x2)…P(xn)P(x1∣S)P(x2∣S)…P(xn∣S)P(S)​</td>
    </tr>
  </tbody>
</table>

<p>위와 같이 수식을 사용하면 문서를 특정 클래스들로 분류하기 위해서는
다음만 알면 된다. <strong>1) 문서로부터 특징벡터를 추출하는 방법 2)기존에
확보된 데이터로부터 P(S∣x)P(S|x)P(S∣x)와 P(!S∣x)P(!S|x)P(!S∣x)를
계산하는 방법 3)각 클래스의 비율인 사전확률
P(S),P(!S)P(S),P(!S)P(S),P(!S).</strong> 해당 문제를 해결하기 위해 주어진
문서로 부터 판단에 사용할 특징feature를 추출해야 하는데 이때 어떤
확률분포를 사용하는지에 따라 특징벡터가 달라지게 된다.</p>

<p><a href="#%EB%82%98%EC%9D%B4%EB%B8%8C-%EB%B2%A0%EC%9D%B4%EC%A6%88-%EB%B6%84%EB%A5%98%EA%B8%B0-3%EC%A2%85%EB%A5%98"></a></p>

<p>나이브 베이즈 분류기 3종류</p>

<p>나이브 베이즈 분류기에는 다음과 같이 3 종류가 있다. 세가지를 모두
다루지는 않고 인턴 기간동안 구현한 Bernoulli naive bayes classifier에
대해서 주로 다룰 것이다. 다만 3종류는 어떠한 것이 있고 각각의 특징과
다른점들에 대해서 간단히 설명하고 넘어가보자.</p>

<ol>
  <li>
    <p>Gaussian naive bayes classifier: 설명변수가 연속형인 경우</p>

    <ul>
      <li>연속적인 데이터에 적용 가능</li>
    </ul>
  </li>
  <li>
    <p>Multinomial naive bayes classifier: 설명변수가 범주형인 경우</p>

    <ul>
      <li>카운트 데이터(횟수)에 적용 가능</li>
    </ul>
  </li>
  <li>
    <p>Bernoulli naive bayes classifier: 설명변수가 이분형인 경우</p>

    <ul>
      <li>이진 데이터에 적용 가능.</li>
    </ul>
  </li>
</ol>

<p>Gaussian naive bayes는 주로 매우 고차원적인 데이터 세트를 다룰 때
사용된다. 나머지 두 베이즈 모델인 다항분포(Multinomial)과
베르누이(Bernoulli)는 보다 텍스트와 같은 데이터에 사용된다. 인턴하는
회사에서 요구한 업무는 문서에 대한 분류기이니 후자가 더 적합하다. 그 중,
내가 맡은 업무는 베르누이를 사용한 나이브 베이즈 문서 분류기이다.</p>

<p><a href="#bernoulli-naive-bayes-%EB%B6%84%EB%A5%98%EA%B8%B0"></a></p>

<p>Bernoulli Naive Bayes 분류기</p>

<p>일부 코드를 제시하면서 구현 로직 설명을 하겠지만 인턴 회사의 코드이므로
모든 공개가 어렵다. 또한 여기서 참고할 점은 구현 언어가 회사 내에서
개발한 새로운 언어라는 것이다. 머신러닝을 사용한 인공지능 회사인 만큼
자체적으로 로직을 짜고 데이터를 처리하기에 더 적합한 언어를 포팅하여
사용하고 있다. 따라서 큰 로직만 참고하는 것을 추천한다.</p>

<p>먼저 텍스트 분류에 크게 사용되는 베르누이 확률 분포 모형과 다항분포
모형을 비교하며 간단히 어떤 차이가 있는지 살펴보자.</p>

<p>먼저 다항분포는 표본벡터 xxx가 있다고 가정했을 때, 이것을 DDD면을 가진
주사위를 yyy번 던진 결과라고 본다. 즉, x=[1,4,0,5]x=[1, 4, 0,
5]x=[1,4,0,5]가 있을 때, 다음 표본벡터는 4면체 주사위를 10번 던져서 1인
면이 1번, 2인 면이 4번, 4인 면이 5번 나온 결과이다. KKK개의 class가
있다면 DDD개 면을 가진 주사위 KKK개가 있다고 보고, 주사위를 던진
결과로부터 1,…,K1, … ,K1,…,K중 어떤 주사위를 던졌는지 찾아내는
것이라고 이해한다. 문서 내에 특정 단어가 몇번 등장하는지에 대한 횟수를
모형화 할 수 있다.</p>

<p>베르누이분포는 xxx의 원소가 0 또는 1 값만을 가질 수 있다. 위와 다르게
독립변수는 DDD개의 독립적인 확률변수를 가지고 있는, 동전으로 구성된 동전
세트로 표현할 수 있다. 각각의 값은 0 또는 1이다. KKK개의 클래스를 가지고
있다고 할 때, 전체 D∗KD * KD∗K의 조합의 동전이 존재하며 같은 class에
속하는 D개의 동전이 하나의 동전 세트를 구성하고 이런 동전 세트가 KKK개
있다고 볼 수 있다. 즉 베르누이를 사용한 나이브 베이즈 모형은 동전 세트를
N번 던진 결과로부터 1, …, KKK 중 어느 동전 세트를 던졌는지 찾아내는
것이다. 문서 내에 특정한 단어가 포함되어 있는지의 여부로 확률을 판단할
때 주로 사용한다.</p>

<ul>
  <li>feature<em>count: 각 class k에 대해 d번째 동전이 앞면이 나온 횟수
$N</em>d,_k$</li>
  <li>feature<em>log</em>prob: 베르누이분포 모수의 로그값</li>
</ul>

<p>logμk=(logμ1,k,…,logμD,k)=(logN1,kNk,…,logND,kNk)log\mu_k =
(log\mu_1,_k,…,log\mu_D,_k) =
(log\frac{N_1,_k}{N_k},…,log\frac{N_D,_k}{N_k})logμk​=(logμ1​,k​,…,logμD​,k​)=(logNk​N1​,k​​,…,logNk​ND​,k​​)</p>

<p>NkN_kNk​는 class k에 대해서 동전을 던진 횟수이다.</p>

<hr />

<p>다음 파이썬 코드를 잠깐 훑으며 베르누이 확률분포를 사용해 나이브베이즈
분류 확률을 구하는 과적을 살펴보자.</p>

<pre><code class="language-{.language-pseudocode}">x = np.array([
[0, 1, 1, 0],
[1, 1, 1, 1],
[1, 1, 1, 0],
[0, 1, 0, 0],
[0, 0, 0, 1],
[0, 1, 1, 0],
[0, 1, 1, 1],
[1, 0, 1, 0],
[1, 0, 1, 1],
[0, 1, 1, 0]])

y = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1]) //class 분류
</code></pre>

<p>클래스는 0과 1로 총 2개라고 본다. xxx는 확률변수를 가지고 있는 동전
세트로 볼 수 있고, yyy는 각 세트에 대한 클래스를 정의해 놓은 것이다.
처음 4개 세트는 class 0, 다음 6개 세트는 class 1이다.</p>

<p>각 클래스 kkk별, 독립변수 ddd별로 총 8개의 베르누이 확률변수의 모수를
구하면 다음과 같다. (각 클래스 별로 합치는 것)</p>

<pre><code class="language-{.language-pseudocode}">array([[2, 4, 3, 1],
       [2, 3, 5, 3]])
</code></pre>

<p>[2,4,3,1][2, 4, 3, 1][2,4,3,1]이 어떻게 나왔는지 간단하게 설명해보겠다.
xxx의 첫번 째 4 세트가 class 0이므로 각각 첫번째 요소가 1인 횟수를
더하여서 2, 두번째 요소가 1인 횟수를 더하여서 4, … 이렇게 합친다.</p>

<p>이렇게 합쳐진 요소들에 대해서 각 클래스의 전체 개수로 나누어 주어야
한다. 위 예시의 경우 class 0의 전체 개수는 4이고 1의 전체 개수는 6이다.
결과는 다음과 같다.</p>

<pre><code class="language-{.language-pseudocode}">array([[0.5,   1,   0.75,    0.25],
       [0.333, 0.5, 0.83333, 0.5]])
</code></pre>

<p>여기서 이제 <strong>스무딩(Smoothing)</strong>을 해야한다. 표본 데이터의 수가 그렇지
않음에도 불구하고 0 또는 1이라는 극단적인 값이 나오게 된다. (현실에서
그런 확률은 거의 없다) 따라서 이런 현상을 방지하기 위해서 베르누이는
모수가 0.5인 가장 일반적인 경를 가정하여서 0이 나오는 경우와 1이 나오는
경우의 가장 표본 데이터를 추가하여 스무딩한다. 주로 smoothing은 가중치
α\alphaα의 값으로 스무딩을 조절한다. 이것을 <em>==라플라스 스무딩(Laplace
smooting)==</em> 또는 <em>==애드원(Add-One) 스무딩==</em>이라고 한다.</p>

<p>μd,k=Nd,k+αNk+2α\mu_d,_k = \frac {N_d,_k + \alpha} {N_k +
2\alpha}μd​,k​=Nk​+2αNd​,k​+α​</p>

<p>위에서 스무딩 가중치 α\alphaα를 1.0을 주었을 때 결과 값은 다음과 같다.
확인해보면 1과 같은 극단적인 값이 없어졌음을 볼 수 있다.</p>

<pre><code class="language-{.language-pseudocode}">array([[0.5,   0.833333, 0.66667, 0.33333],
       [0.375, 0.5,      0.75,    0.5]])
</code></pre>

<p>예측을 하기 위해 [0,0,1,1][0, 0, 1, 1][0,0,1,1] 을 입력하면
array([0.0953,0.9046])array([0.0953 , 0.9046])array([0.0953,0.9046])
값이 나온다. 즉 3, 4번 키워드가 포함되어 있다면 class 1 일 확률이
90%라는 의미이다.</p>

<p><a href="#implementation---%EB%AC%B8%EC%84%9C-%EB%B6%84%EB%A5%98%EA%B8%B0-%EA%B5%AC%ED%98%84"></a></p>

<p>Implementation - 문서 분류기 구현</p>

<p>원리를 이해했다면 구현은 생각보다 간단하다. 물론 파이썬의 sklearn등의
모듈을 사용하면 나이브 베이즈와 각 확률분포에 대한 기능이 모두 구현되어
있다. 따라서 가져가 쓰기면 하면 된다. 여기서는 문서분류기에 해당
알고리즘을 모듈을 사용하지 않고 어떻게 구현해야 하는지를 다룰 것이다.
앞서 말했든 사내에서 쓰는 언어를 사용한 것이 때문에 코드구현은 플로우만
참고하는 것을 추천한다.</p>

<p><a href="#%ED%95%99%EC%8A%B5-learn"></a></p>

<p>학습 Learn</p>

<ul>
  <li>Input: 텍스트, 분류 클래스</li>
  <li>문서 키워드를 추출한다. 키워드 추출은 사용자마다 다른 기능이나
모듈을 가져와서 기준에 따라 추출할 수 있다.</li>
  <li>중복 제거를 위해 추출된 키워드를 Set에 입력시킨다.</li>
  <li>클래스 횟수가 저장되어 있는 자료구조에 해당 클래수 횟수를 1
증가시킨다.</li>
  <li>해당 클래스의 해당 단어의 여부를 기록하기 위해 해당 자료구조에 1을
더한다.</li>
  <li>전체 단어를 저장하는 자료구조에 단어를 추가한다.</li>
</ul>

<p>위에서 설명한 베르누이 확률분포를 계산하기 위한 Nd,kN_d,_kNd​,k​와
NkN_kNk​를 계산하는 과정으로 이해하면된다. 다음은 해당을 특정 언어로
코딩한 일부분이다. 여기서 m<em>n</em>cls와 m<em>n</em>cls<em>word등의 자료구조는 hash이고
m</em>words는 set이다.</p>

<pre><code class="language-{.language-c++}">void BernoulliModel::learn(string text, string cls){
    list&lt;string&gt; tok;
    tok = extract_words(text.trim(), m_lang, m_charset;
    m_n_cls[cls] +=1;
                        
    set&lt;string&gt; word_set;
    string word;
    for word in tok {
        word_set.add(word);
    }                    
    
    for word in word_set {
        m_n_cls_word[cls+"_"+word] += 1;
        m_words.add(word);
    }                    
}
</code></pre>

<p><a href="#%EC%98%88%EC%B8%A1-predict"></a></p>

<p>예측 Predict</p>

<ul>
  <li>Input: 예측할 테스트, Smoothing을 위한 α\alphaα</li>
  <li>입력 텍스트에 대해서 키워드를 추출함</li>
  <li>클래쓰 목록을 가져와서 각 클래스마다 다음을 반복함(해당 클래스의
Score를 구함)</li>
  <li>분모에 총 클래스 횟수와 smoothing값을 더함.</li>
  <li>추출된 각 키워드에 대해서 확률분포값과 smoothing 값을 더하여서 위의
분모로 나눈 log를 계산함(위에 베르누이 확률 계산 공식을 참고)</li>
  <li>각 클래스의 점수를 누적하여 예측함.</li>
</ul>

<pre><code class="language-{.language-pseudocode}">BernoulliModel::predict(string fe, string lang, string charset, hash&lt;string,double&gt;&amp; score_hash, double alpha){
    list&lt;string&gt; tok;
    list&lt;string&gt; cls_list;
    double denom;
    double score;
    string cls;
    string t;
    
    tok = extract_word(fe.trim(), lang, charset);
    cls_list = m_n_cls.key();
    
    for cls in cls_list {
        socre = 0.0;
        denom = double(m_n_cls[cls]) + 2*alpha;
        for t in tok{
            score += log(m_n_cls_wor[cls+"_"+t]+alpha) / denom);
        }
        score_hash[cls] += score;
    }
}
</code></pre>

<p>다음을 예측해서 Score가 가장 높은 cls 소속임을 예측한다. 다항분포
모델이랑 비교하여 새로 구현한 베르누이 나이브 베이즈 문서 분류기의
성능을 테스트 해 보았을 때 81~82% 정도의 정확성을 보이는 것을 확인했다.
다항분포는 84~85%정도의 성능이었던 것을 고려해보면 확실히 정확한
횟수보다 여부만을 가지고 계산하는 베르누이 분류기의 성능이 다소 떨어지는
것을 확인할 수 있었다.</p>

<ul>
  <li>결과:</li>
</ul>

<p><a href="/static/adc092bf4b98644a4cd46e8df3167bf9/533c1/Bernoulli.png"><img src="/static/adc092bf4b98644a4cd46e8df3167bf9/533c1/Bernoulli.png" alt="Bernoulli
result" title="Bernoulli result" /></a></p>

<p><strong>[참고
자료]:</strong>  <a href="https://nbviewer.jupyter.org/github/metamath1/ml-simple-works/blob/master/naive/naive.ipynb">https://nbviewer.jupyter.org/github/metamath1/ml-simple-works/blob/master/naive/naive.ipynb</a>,
<a href="https://wikidocs.net/22892">https://wikidocs.net/22892</a>, <a href="https://heung-bae-lee.github.io/2020/04/14/machine_learning_07/">https://heung-bae-lee.github.io/2020/04/14/machine_learning_07/</a></p>


	  ]]></description>
	</item>

	<item>
	  <title>[알고리즘] 세그먼트 트리를 활용한 히스토그램 문제 풀이_2</title>
	  <link>//segment-tree2</link>
	  <author></author>
	  <pubDate>2020-09-10T10:18:00+00:00</pubDate>
	  <guid>//segment-tree2</guid>
	  <description><![CDATA[
	     <p>앞서 <a href="https://www.acmicpc.net/problem/6549">히스토그램 문제</a>에 대한 접근 방법을 간단하게 설명하고 세그먼트 트리를 히스토그램에 맞추어서 설명했다. 이번 글에서는 구체적으로 어떻게 세그먼트 트리를 구현하여 히스토그램 문제를 푸는데까지 이어지는지 다루어 보도록 하겠다.</p>

<p>이 문제는 레벨이 높은 문제이긴 하지만 아이디어 자체가 굉장히 어렵거나 하진 않다. 다만 시간 복잡도 측면에서 효율적으로 접근하기 위해 세그먼트 트리를 활용하는게 좀 낯설어서 어려웠던 것 같다.</p>

<h6 id="segment-tree-구현">Segment Tree 구현</h6>

<p>Segment Tree를 구현할 때 배열을 사용해서 구현하도록 할텐데 segment tree는 다음과 같은 성질을 가지고 있다.</p>

<ul>
  <li>세그먼트 트리는 거의 Full Binary Tree(비슷한 형태를 지님)의 모습을 하고 있다.</li>
  <li>왼쪽 자식: 부모노트 * 2</li>
  <li>오른쪽 자식: 부모노드 * 2 + 1</li>
  <li>높이: lgN</li>
</ul>

<p>배열을 통해서 tree를 구현하려면 사전에 tree의 노드 갯수를 파악해서 배열의 크기를 지정해야한다. 위의 성질들을 이용하면 해당 tree의 크기를 계산할 수 있다. 예를 들어 기존 배열의 개수가 <strong>2의 제곱인 경우</strong>에는 높기가 lgN 이므로 필요한 노드의 갯수는 <code class="highlighter-rouge">2*N-1</code> 이다. <strong>2의 제곱이 아닌 경우</strong>에는 N보다 큰지만 가장 가까운 2의 제곱을 찾으면 된다. 따라서 그 경우 노드의 갯수는 <code class="highlighter-rouge">2*2^(lgN+2)-1</code>이 된다.</p>

<p>이렇게 크기를 지정해서 배열을 생성한 이후에 재귀 함수를 사용해서 이전 포스트에서 이야기 했던 부분을 구현하면 된다. 재귀를 잘 이해했다면 segment tree 생성은 크게 어렵지 않다.</p>

<p>**코드: **</p>

<p>먼저 segment tree를 저장할 배열 공간을 할당한다.  다음은 구현할 때 유용한 몇가지 JAVA 함수를 소개해준다.</p>

<ul>
  <li>Ceil: 올림 숫자</li>
  <li>Math.log10(n)/Math.log10(2) = log2n</li>
</ul>

<p>Segment Tree의 index는 1부터 시작해야 한다. 그래야지 <code class="highlighter-rouge">2*i, 2*i+1</code>로 왼쪽 자식노드와 오른쪽 자식노드를 구별할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
  <span class="o">...</span>
  <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">ceil</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">log10</span><span class="o">(</span><span class="n">n</span><span class="o">)/</span><span class="n">Math</span><span class="o">.</span><span class="na">log10</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">height</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
  
  <span class="kt">int</span><span class="o">[]</span> <span class="n">binTree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
  <span class="n">init</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>다음은 segment tree에 값을 할당하는 부분이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
  <span class="k">if</span><span class="o">(</span><span class="n">start</span><span class="o">==</span><span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="n">init</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="o">(</span><span class="n">start</span><span class="o">+</span><span class="n">end</span><span class="o">)/</span><span class="mi">2</span><span class="o">,</span> <span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">);</span>
  <span class="n">init</span><span class="o">((</span><span class="n">start</span><span class="o">+</span><span class="n">end</span><span class="o">)/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
  <span class="k">if</span><span class="o">(</span><span class="n">value</span><span class="o">[</span><span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">]]&lt;=</span><span class="n">value</span><span class="o">[</span><span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">]])</span>
    <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">];</span>
  <span class="k">else</span>
    <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
  <span class="k">return</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h6 id="segment-tree-탐색">Segment Tree 탐색</h6>

<p>Segment Tree를 생성했으면 이제 각 구간을 순회하며 해당 구간의 최소값을 구해야 한다. 일반적인 세그먼트 트리의 예시에서 구간합을 구할 경우 각 segment tree에 있는 값의 합을 구하면 되지만, 히스토그램 문제에서는 최소값을 찾아야 하니, 한번 더 참조해야 하는 부분이 있다.</p>

<p>이 부분은 세그먼트 트리에 대해서 설명해놓은 <a href="https://www.acmicpc.net/blog/view/9">백준 블로그</a>를 참조하면서 이해 했는데 매우 잘 설명이 되어 있다. 세그먼트의 해당 노드가 담당하고 있는 구간을 [start, end]로, 합을 구하는 목적 구간을 [left, right]로 놓았을 때 다음 4가지 경우가 있다.</p>

<ol>
  <li>합을 구해야하는 [left, right]와 현재 노드가 담당하고 있는 [start, end]가 겹치지 않는 경우</li>
  <li>합을 구해야하는 [left, right]가 현재 노드가 담당하고 있는 [start, end]를 완전히 포함하는 경우</li>
  <li>현재 노드가 담당하고 있는 [start, end]가 [left, right]를 완전히 포함하는 경우</li>
  <li>[left, right]와 [start, end]가 겹쳐져 있는 경우 (1, 2, 3을 제외한 나머지)</li>
</ol>

<p>위의 4가지 경우에 대해서 다음과 같이 처리한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1번 경우: if(left &gt; end || right &lt; start) 
	- 겹치지 않으므로 탐색할 필요 없음
2번 경우: if(left &lt;= start &amp;&amp; end &lt;= right)
	- 해당 노드의 값을 리턴함
3,4번 경우:
	- 각각 왼쪽, 오른쪽 자식 노드에서 탐색함. 
</code></pre></div></div>

<p>히스토그램 문제에서는 최소값을 찾아야 하는 것이기 때문에 왼쪽과 오른쪽 자식 노드로 나누어서 들어갈 때, 배열을 한번 더 참조해서 구간에서 최종 최소값이 있는 위치를 찾아야 한다.</p>

<p><strong>코드:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMin</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">last</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
  <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">&gt;</span><span class="n">last</span> <span class="o">||</span> <span class="n">right</span><span class="o">&lt;</span><span class="n">start</span><span class="o">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="o">&gt;=</span><span class="n">last</span><span class="o">)</span>
    <span class="k">return</span> <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">findMin</span><span class="o">(</span><span class="n">start</span><span class="o">,(</span><span class="n">start</span><span class="o">+</span><span class="n">last</span><span class="o">)/</span><span class="mi">2</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">temp2</span> <span class="o">=</span> <span class="n">findMin</span><span class="o">((</span><span class="n">start</span><span class="o">+</span><span class="n">last</span><span class="o">/</span><span class="mi">2</span><span class="o">)+</span><span class="mi">1</span><span class="o">,</span> <span class="n">last</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">temp1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">temp2</span><span class="o">;</span>
    <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">temp2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">temp1</span><span class="o">;</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">if</span><span class="o">(</span><span class="n">value</span><span class="o">[</span><span class="n">temp1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">value</span><span class="o">[</span><span class="n">temp2</span><span class="o">])</span>
        <span class="k">return</span> <span class="n">temp1</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">temp2</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h6 id="히스토그램-풀이">히스토그램 풀이</h6>

<p>위의 세그먼트 트리 생성과 탐색 방법을 사용해서 최소값을 찾는 부분을 구현했다면 이제 답을 구현하도록 해보자. 앞의 포스트에서 언급했던 방법은 아래이다.</p>

<blockquote>
  <p>먼저 <a href="https://www.acmicpc.net/problem/6549">문제</a>의 해결 방법을 요약하면 다음과 같다.</p>

  <blockquote>
    <ol>
      <li>히스토그램 중, 높이가 가장 낮은 min 값과 해당 너비값을 곱하여 넓이를 구함.</li>
      <li>해당 최소값을 기준으로 히스토램을 나누어서 1번을 반복함.</li>
      <li>더 이상 나눌 수 없을 때까지 반복하며 매번 넓이의 max 값을 업데이트 함.</li>
    </ol>
  </blockquote>
</blockquote>

<p>위의 방법이 분할정복인 이유는 반복적으로 나뉘어지는 구간에서의 직사각형을 계속 비교하면서 최대 크기를 찾기 때문이다. 세그먼트 트리에 저장된 최소값의 위치를 활용해서 해당 기준으로 나누고, 나눈 구간에서의 직사각형 넓이 구할 때 사용하도록 한다.</p>

<p>**코드: **</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lastIndex</span><span class="o">){</span>
  <span class="kt">long</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">startIndex</span> <span class="o">==</span> <span class="n">lastIndex</span><span class="o">){</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">startIndex</span><span class="o">];</span>
    <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
      <span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kt">int</span> <span class="n">minIndex</span> <span class="o">=</span> <span class="n">findMin</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">startIndex</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
  <span class="kt">long</span> <span class="n">min</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">minIndex</span><span class="o">];</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">minIndex</span> <span class="o">==</span> <span class="n">startIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">minIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">minIndex</span> <span class="o">&gt;=</span> <span class="n">lastIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">minIndex</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">minIndex</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">minIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong><small>[참고 자료]: https://www.acmicpc.net/blog/view/12, https://www.crocus.co.kr/648, https://www.acmicpc.net/blog/view/9 </small></strong></p>


	  ]]></description>
	</item>

	<item>
	  <title>[알고리즘] 세그먼트 트리를 활용한 히스토그램 문제 풀이_1</title>
	  <link>//segment-tree1</link>
	  <author></author>
	  <pubDate>2020-09-09T10:18:00+00:00</pubDate>
	  <guid>//segment-tree1</guid>
	  <description><![CDATA[
	     <p>히스토그램에서 가장 큰 직사각형의 크기를 찾는 알고리즘을 풀다가, 관련 문제의 풀이법을 간단히 찾아서 금방 해결할 줄 알았으니 구현에서 의도치 않은 오랜 시간이 걸렸다.</p>

<p>먼저 <a href="https://www.acmicpc.net/problem/6549">문제</a>의 해결 방법을 요약하면 다음과 같다.</p>

<blockquote>
  <ol>
    <li>히스토그램 중, 높이가 가장 낮은 min 값과 해당 너비값을 곱하여 넓이를 구함.</li>
    <li>해당 최소값을 기준으로 히스토램을 나누어서 1번을 반복함.</li>
    <li>더 이상 나눌 수 없을 때까지 반복하며 매번 넓이의 max 값을 업데이트 함.</li>
  </ol>
</blockquote>

<p>다음은 <a href="https://www.acmicpc.net/blog/view/12">백준 블로그</a>에 있는 문제 해설에서 가져온 그림이다. 위의 해결 방법을 이해하는데 도움이 된다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/109445062-10bb9c80-7a82-11eb-9887-9047f1485785.png" alt="histogram" /></p>

<p>처음에 단순히 이 풀이방법을 배열과 재귀를 사용해서 구현하는 방법으로 시도를 했었다. 사이트에 나와있는 테스트 케이스가 통과하길래 바로 채점을 했더니 결과는 <em>시간초과</em> 였다.. 개인적으로 알고리즘을 할 때 가장 어려운 부분이 답을 출력이 되지만 시간초과가 나올 때 인 것 같다. 문제설명 밑에 해당 문제를 세그먼트 트리를 사용한 분할정복으로 풀 수 있다고 하길래 세그먼트 트리에 대해서 공부하면서 정리한 내용과 처음에 접근했던 방식에 대해서 쓰려고 한다.</p>

<ol>
  <li>배열/재귀를 사용해서 풀었던 방법: <mark> 시간초과 </mark></li>
  <li>세그먼트 트리/분할정복을 사용해서 푼 방법: <mark>통과</mark></li>
</ol>

<h3 id="배열과-재귀를-사용한-첫번째-접근-방법">배열과 재귀를 사용한 첫번째 접근 방법</h3>

<p>배열과 재귀를 사용한 접근 방법은 간단하지만 번거롭다. 매번 나뉘어진 구간 사이에서의 <strong>최솟값</strong>을 찾는 과정을 반복해야 하기 때문이다.</p>

<h4 id="접근-방법-1-arraylist">접근 방법 1: ArrayList</h4>

<p>ArrayList를 사용해서 탐색 API를 사용해서 최솟값 구하기</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. ArrayList의 일부 구간을 subList를 사용하여 List에 저장한다.
2. Collections.min() 메소드를 사용하여 최솟값을 추출하여 넓이를 구한다. 
3. indexOf() 메소드를 사용하여 최솟값의 index를 구한다. 
4. 다음과 같은 재귀로 반복한다.
	* 맨 첫번째 요소가 최소값일 경우: 두번째 요소부터 마지막 요소까지 재귀
	* 맨 마지막 요소가 최소값일 경우: 첫본째 요소부터 마지막 이전 요소까지 재귀
	* 중간의 어느 값이 최소값일 경우: (시작 요소, 최소값 위치 -1)과 (최소값 위치 +1, 마지막 요소)로 나누어서 재귀
</code></pre></div></div>

<p>위의 방식은 조금만 큰 값이 들어가도 바로 <em>시간 초과</em>가 결렸다. 이유는 ArrayList의 경우 일반 배열과 달리 초반에 메모리 할당이 되지 않기 때문에 추가/삭제 시 메모리 할당을 매번 해줘야 한다. 따라서 일반적으로 일반 배열이 더욱 빠르다. 그래서 두번째 접근 방식으로 일반 배열을 사용하는 것을 택했다. 일반 배열을 사용하면 최소값을 찾는 등의 메소드를 사용하기는 어렵지만 최소값을 찾는 구현은 어렵지 않고, 시간 복잡도도 비슷하기 때문에 시도해 보았다.</p>

<p><strong>코드:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lastIndex</span><span class="o">){</span>
  <span class="kt">long</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">startIndex</span> <span class="o">==</span> <span class="n">lastIndex</span><span class="o">){</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">startIndex</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
    	<span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
  <span class="kt">long</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
  <span class="n">area</span> <span class="o">=</span> <span class="n">min</span><span class="o">*(</span><span class="n">lastIndex</span><span class="o">-</span><span class="n">startIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">startIndex</span> <span class="o">+</span> <span class="n">list</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">min</span><span class="o">);</span>
  <span class="k">if</span><span class="o">(</span><span class="n">area</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">startIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">lastIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
  <span class="k">else</span><span class="o">{</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="접근-방법-2-arrays">접근 방법 2: Arrays</h4>

<p>Array를 사용해서 최소값을 구하기</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. for-loop를 사용해서 최소값 구하기
2. 최소값 사용하여 넓이 구하기 
3. 접근 방법 1에서와 같이 재귀하기
</code></pre></div></div>

<p>ArrayList를 사용했을 때보다는 빨랐기 때문에 더 많은 test case를 통과할 수 있었다. 하지만 여전히 시간초과에 걸렸다.</p>

<p>문제에서 나온 직사각형의 갯수 제한은 100,000이고 재귀 초기함수가 <code class="highlighter-rouge">(startIndex==lastIndex)</code> 일 때이기 때문에 각각하나씩 모두 접근한다. 이때마다 해당 구간의 최소값을 찾기위해 O(n)만큼 탐색을 하니 시간 초과가 걸릴만 하다. 때문에 문제의 태그에서 나온 세그먼트 트리에 대해서 공부하고 활용해보기로 했다.</p>

<p><strong>코드:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lastIndex</span><span class="o">){</span>
  <span class="kt">long</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">long</span> <span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="kt">long</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">startIndex</span><span class="o">==</span><span class="n">lastIndex</span><span class="o">){</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">startIndex</span><span class="o">];</span>
    <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
      <span class="n">max</span><span class="o">=</span><span class="n">area</span><span class="o">;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">startIndex</span><span class="o">;</span><span class="n">temp</span><span class="o">&lt;=</span><span class="n">lastIndex</span><span class="o">;</span><span class="n">temp</span><span class="o">++){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">min</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">value</span><span class="o">[</span><span class="n">temp</span><span class="o">]&lt;</span><span class="n">min</span><span class="o">){</span>
      <span class="n">min</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">temp</span><span class="o">];</span>
      <span class="n">index</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="n">area</span> <span class="o">=</span> <span class="n">min</span><span class="o">*(</span><span class="n">lastIndex</span><span class="o">-</span><span class="n">startIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">startIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">lastIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
  <span class="k">else</span><span class="o">{</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="접근-방법-3-segment-tree">접근 방법 3: Segment Tree</h4>

<p>세그먼트 트리는 <mark>주어진 쿼리에 빠르게 응답하기 위해 만들어진 자료구조</mark>이고, 그 사용법은 쿼리마다 상이하다. 가장 대표적으로 세그먼트 트리를 사용할 때 내는 예시는 구간 합을 구하는 문제이다. 하지만 이 글에서는 <em>히스토그램에서 가장 큰 직사각형</em> 푸는 문제에 적용된 세그먼트를 설명할 것이다.</p>

<p>풀이에 세그먼트 트리를 활용할 수 있는 상황은 다음 두가지와 같다. <strong>1. 쿼리 형식으로 문제가 주어진 경우 2. 시간 복잡도를 log로 만들고 싶을 경우</strong>. <small>개인적으로 구간에 관련한 문제가 나올 경우, 시간 복잡도를 줄이기 위해 세그먼트 트리 사용을 하는 것이 좋은 것 같다.</small></p>

<p>세그먼트 트리는 주로 이진트리를 이용하며, 주로 완전 이진 트리 Full Binary Tree에 가깝다. 그렇기 대문에 세그먼트 트리를 사용하면 다음과 같은 성능을 지닌다.</p>

<ol>
  <li>쿼리의 결과값 구하기: O(lgN)</li>
  <li>값 업데이트 하기: O(lgN)</li>
</ol>

<p>히스토그램 문제에서는 쿼리의 결과값 구하는 과정의 시간 복잡도가 O(lgN)이 되면서 성능이 매우 좋아지게 된다.</p>

<h6 id="segment-tree-란">Segment Tree 란?</h6>

<p><img src="https://user-images.githubusercontent.com/63405904/109445201-6e4fe900-7a82-11eb-8e6c-09edb7e236a4.png" alt="histogram" /></p>

<p>히스토그램 문제에서는 위에서 말했듯 다음 두가지 풀이를 반복한다.</p>

<ol>
  <li>
    <p>최소값 기준으로 구간 나누기</p>
  </li>
  <li>
    <p>나뉘어진 구간에서 재귀로 1) 반복하기</p>
  </li>
</ol>

<p>히스토그램에서 중요 요소는 최소값이기 때문에 각 구간의 최소값의 위치를 저장하도록 한다. 따라서 이후에 특정 구간의 최소값을 찾을 때 <mark>O(lgN)</mark>만큼의 시간복잡도로 최소값을 찾을 수 있다. 위의 이진 세그먼트 트리는 10개의 원소가 있다고 가정했을 때 각 구간이 나뉜 것을 보여준다. <strong>세그먼트 트리에서 모든 leaf node는 원래 배열의 자기자신 element</strong>이다.</p>

<p>요약하자면 segment tree의 구성요소는 다음과 같다.</p>

<ul>
  <li>Leaf node :  원래 배열의 그 수의 위치. <small>(이 값은 응용 문제에 따라서 달라진다.)</small></li>
  <li>다른 node:  왼쪽 자식과 오른쪽 자식 중 더 최소값의 위치.</li>
</ul>

<p>히스토그램 문제에서 Segment tree 구현을 요약하면 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 초기화 함수: 구간이 자기 자신일 경우, leaf node이므로 해당 위치를 기록함. 
2. 재귀 함수: 구간을 반으로 나누어서 재귀함.
3. 일반 함수: 자신의 왼쪽 자식 노드와, 오른쪽 자식 노드 위치의 값을 비교하여 더 작은 값의 위치를 트리의 해당 노트에 입력함. 
</code></pre></div></div>

<p>전체 구간 <code class="highlighter-rouge">0 ~ n-1</code>까지부터 시작해 재귀를 하면 각 구간마다의 <mark>최솟값의 위치</mark>를 기록한 <em>lgN</em> 높이 만큼의 segment tree가 생성된다. 이 세그먼트 트리를 사용해서 더 빠른 방법으로 최소값을 탐색하고 제일 앞에서 설명한 방법을 통해서 정답을 도출하면 된다.</p>

<hr />

<p>다음 글에서 구체적으로 세그먼트 트리를 구현하는 방법과 히스토그램에서 응용된 방법에 대해서 다루도록 하겠다.</p>

<p><strong><small>[참고 자료]: https://www.acmicpc.net/blog/view/12, https://www.crocus.co.kr/648, https://www.acmicpc.net/blog/view/9 </small></strong></p>

	  ]]></description>
	</item>

	<item>
	  <title>[알고리즘] 쿼드 트리</title>
	  <link>//quadTree</link>
	  <author></author>
	  <pubDate>2020-08-12T10:18:00+00:00</pubDate>
	  <guid>//quadTree</guid>
	  <description><![CDATA[
	     <p>자료구조 중 처음 들어본 <small>(배웠는데 기억 못하는)</small> 개념이 나와서 정리해본다. 알고리즘 문제 중 분할 문제를 푸는 중에 쿼드 트리를 사용하는 알고리즘 이라는 언급을 보고 쿼드 트리라는 것이 어떠한 것인지 살펴보기로 한다.</p>

<ul>
  <li>QuadTree(쿼드트리): 자료구조의 트리를 기반으로 자식노드가 4개인 트리를 의미함.</li>
</ul>

<p>대랑의 좌표 데이터를 메모리 안에 압축하기 위해서 사용하는 기법 중 하나로, 주어진 공간을 항상 4개로 분할해 재귀적으로 표현한다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/110094205-ea2d9680-7dde-11eb-95ce-eb1b0156b256.png" alt="quadTree" /></p>

<p>대표적으로 사용되는 쿼드 트리의  사용처는 검은 색과 흰 색 밖에 없는 흑백 그림을 압축해서 표현하는 것이다. 쿼드 트리를 사용해서 해당 문제를 해결하는 것을 간단히 살펴보자.</p>

<h2 id="쿼드트리-응용-예시">쿼드트리 응용 예시</h2>

<p><strong>흑백그림 압축표현 하기</strong></p>

<p>다음 3가지를 기억하고 논리를 따라가면 된다.</p>

<ol>
  <li>그림의 모든 픽셀이 검은 색일 경우 쿼드 트리의 압축 결과는 그림 크기에 상관없이 B가 됨.</li>
  <li>그림의 모든 픽셀이 흰 색일 경우 쿼드 트리의 압축 결과는 그림 크기에 상관없이 W가 됨.</li>
  <li>같은 색이 아니라면, 이 그림의 가로 세로에 대해서 2로 나누어 4개의 조각으로 나눈 다음에 재귀를 사용하여 쿼드 트리압축을 진행함.
    <ul>
      <li>각각 4개의 분할된 그림에 대해서 전체가 흑색이면 B가 되고 전체가 흰색이면 W가 됨.</li>
      <li>만일 같은 색깔로 나누어지지 않으면 X로 표시한 후, 재귀로 들어가 색갈이 나올 때까지 반복함.</li>
    </ul>
  </li>
</ol>

<h2 id="쿼드트리를-응용한-그림-압축하기-코드">쿼드트리를 응용한 그림 압축하기 코드</h2>

<p>자바로 트리를 구현하는 방법 중 하나는, 재귀로 하나씩 파고드는 것이다. 재귀와 분할정복에 대해서 몇 문제를 풀어보니 중요한 것은 다음 두가지 이다.</p>

<ol>
  <li>언제 return 할 것인지.</li>
  <li>재귀로 들어가는 반복적인 규칙</li>
</ol>

<p>위 두가지를 고려하여 쿼드 트리로 위의 흑백 그림에 대해서 푸는 코드를 작성해보자.</p>

<p>문제는 <a href="https://www.acmicpc.net/problem/2630">백준 2630번</a> 를 참고하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Divide and Conquere 분할정복</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>
  <span class="kd">static</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kd">static</span> <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
    
    <span class="k">try</span><span class="o">{</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
          <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">temp</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
        <span class="o">}</span>
      <span class="o">}</span>
      <span class="n">solve</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">){}</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
  		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">x</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">x</span><span class="o">+</span><span class="n">size</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">y</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">y</span><span class="o">+</span><span class="n">size</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]){</span>
          <span class="n">solve</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span>
          <span class="n">solve</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span>
          <span class="n">solve</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">+</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span>
          <span class="n">solve</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">y</span><span class="o">+</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span>
          <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
      <span class="n">b</span><span class="o">++;</span>
    <span class="k">else</span> 
      <span class="n">w</span><span class="o">++;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><small>별건 아니고 이진트리에서 4개 버전이 쿼드 트리였다..</small></p>


	  ]]></description>
	</item>


</channel>
</rss>
