<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>yjksw.github.io/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA] 구글에서 제공하는 Java Coding Convention Guide</title>
	  <link>//java-coding-convention</link>
	  <author></author>
	  <pubDate>2020-11-28T10:18:00+00:00</pubDate>
	  <guid>//java-coding-convention</guid>
	  <description><![CDATA[
	     <p><br /></p>

<p>프리코스를 진행하면서 구글에서 제공하는 javaGuide를 읽고 해당 convention을 따라서 코딩 하도록 하기 위해서 해당 문서를 정독했다. 원래 알고 있던 부분들도 있고 아닌 부분들도 있는데, 이렇게 잘 문서화 되어 있다는 것을 처음 알았다. 다음은 해당 문서를 읽으면서 두고두고 참고할 내용들을 정리한 것들이다.</p>

<p>다음 사이트 참고: <a href="https://google.github.io/styleguide/javaguide.html">Google Java Style Guide</a></p>

<h2 id="1-source-file-structure">1. Source file structure</h2>

<p>Java 소스 파일은 다음과 같은 구조를 가지고 있다. 순서에 유의하여 구조화 되어 있다.</p>

<ol>
  <li>만약 존재한다면, license or copyright information</li>
  <li>Package 명시</li>
  <li>Import statements</li>
  <li>단 하나의 top-level class</li>
</ol>

<p>→ 위의 4 section을 1줄 간격(exactly one blank)으로 나눈다.</p>

<p><br /></p>

<h3 id="1-1-copyright-information">1-1. copyright information</h3>

<p>소스파일 맨 위에 시작 주석으로 파일 클래스 이름, 버전 정보, 날짜, 저작권 주의를 보여주는 주석으로 시작한다.</p>

<h3 id="1-2-import-statements">1-2. Import Statements</h3>

<ol>
  <li>Wildcard imports는 지양한다.
    <ul>
      <li>(*) 추가해서 전체를 한꺼번에 import 하는 것.</li>
      <li><a href="https://medium.com/@tharakamd.12/is-it-bad-to-use-wildcard-imports-in-java-1b46a863b2be#:~:text=Wildcard%20imports%20tell%20java%20compiler,performance%20may%20lower%20a%20bit">관련 참고 사이트</a></li>
    </ul>
  </li>
  <li>한 줄이 너무 길어도 line wrapping 하지 않는다.</li>
  <li>static imports를 하나의 block에 non-static imports를 하나의 block에 넣고 두 block 사이만 한 줄 간격이 있다.</li>
  <li>각 block 내에서는 ASCII sort order에 따라서 정렬한다.</li>
  <li>class는 static import 가 아닌 normal import 한다.</li>
</ol>

<h3 id="1-3-class-declaration">1-3 Class Declaration</h3>

<ol>
  <li>Top-level 클래스는 각 소스파일 당 단 1개만 존재한다.</li>
</ol>

<p><br /></p>

<h2 id="2-formatting">2. Formatting</h2>

<h3 id="2-1-괄호">2-1. 괄호</h3>

<ol>
  <li>
    <p>optional인 경우에도 괄호를 쓴다.</p>

    <ul>
      <li><code class="highlighter-rouge">if, else, for, do, while</code> 이 비어 있거나 한 줄만 있더라도 괄호를 추가한다.</li>
    </ul>
  </li>
  <li>비어 있지 않은 블록의 경우 다음과 같이 한다.
    <ul>
      <li>’{‘ 앞에 줄 간격 두지 않는다.</li>
      <li>’{‘ 이후에  줄 간격 둔다.</li>
      <li>’}’ 이전에 줄 간격 둔다.</li>
      <li>’}’ 이후에 다음과 같은 경우에만 줄 간격을 둔다.
        <ul>
          <li>statement가 끝났을 때, 메소드, constructor, class가 끝났을 때</li>
          <li>, 나 else 가 그 다음에 나오는 경우에는 줄 간격을 두지 않는다.</li>
        </ul>
      </li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
   <span class="k">while</span> <span class="o">(</span><span class="n">condition</span><span class="o">())</span> <span class="o">{</span>
     <span class="n">method</span><span class="o">();</span>
   <span class="o">}</span>
 <span class="o">};</span>

 <span class="k">return</span> <span class="k">new</span> <span class="nf">MyClass</span><span class="o">()</span> <span class="o">{</span>
   <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">()</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">())</span> <span class="o">{</span>
       <span class="k">try</span> <span class="o">{</span>
         <span class="n">something</span><span class="o">();</span>
       <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ProblemException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">recover</span><span class="o">();</span>
       <span class="o">}</span>
     <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">otherCondition</span><span class="o">())</span> <span class="o">{</span>
       <span class="n">somethingElse</span><span class="o">();</span>
     <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
       <span class="n">lastThing</span><span class="o">();</span>
     <span class="o">}</span>
   <span class="o">}</span>
 <span class="o">};</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>빈 블록의 경우:</p>

    <p>다음 두 경우 모드 가능하나, multi-block 인 경우에는 consice 하게 할 수 없다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// This is acceptable</span>
   <span class="kt">void</span> <span class="nf">doNothing</span><span class="o">()</span> <span class="o">{}</span>

   <span class="c1">// This is equally acceptable</span>
   <span class="kt">void</span> <span class="nf">doNothingElse</span><span class="o">()</span> <span class="o">{</span>
   <span class="o">}</span>
</code></pre></div>    </div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// This is not acceptable: No concise empty blocks in a multi-block statement</span>
   <span class="k">try</span> <span class="o">{</span>
     <span class="n">doSomething</span><span class="o">();</span>
   <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="2-2-블록-indentation-2-spaces">2-2. 블록 indentation: +2 spaces</h3>

<ul>
  <li>새로운 블록일 경우 2 만큼 들여쓰기 한다.</li>
  <li>하지만 우테코에서는 +2 가 아니라 +4 만큼 들여쓰기 하도록 한다.</li>
</ul>

<h3 id="2-3-한-줄에-한-statement만-작성한다">2-3 한 줄에 한 statement만 작성한다.</h3>

<ul>
  <li>각 statement는 줄 간격을 둔다.</li>
</ul>

<h3 id="2-4-column-limit-100">2-4 Column limit: 100</h3>

<p>다음과 같은 경우가 아니라 한 줄에 100자가 넘지 않도록 line-wrapping을 한다.</p>

<ol>
  <li>line-wrapping이 불가능한 경우</li>
  <li>package / import 일 경우</li>
  <li>shell에 복사 붙여넣기 해야 하는 comment일 경우</li>
</ol>

<h3 id="2-5-line-wrapping">2-5 Line-wrapping</h3>

<ul>
  <li>다음과 같은 상황에서 line break를 하여 line-wrapping 한다.
    <ol>
      <li>
        <p>non-assignment operator일 경우 줄 간격은 해당 Operator 앞에서 break 한다.</p>

        <p>다음과 같은 것들에도 적용된다:</p>

        <ul>
          <li>dot separator (.)</li>
          <li>two colons of method reference (::)</li>
          <li>an ampersand in a type bound (&lt;T extends Foo &amp; Bar&gt;)</li>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>pipe in a catch block ( catch (FooException</td>
                  <td>BarException e) )</td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
      </li>
      <li>assignment-operator일 경우 해당 operator 다음에 line break 한다.</li>
      <li>( 앞에 있는 메소드나 constructor 이름은 붙어 있도록 한다.</li>
      <li>, 같은 경우 그 앞의 토큰과 붙어 있는다.</li>
      <li>
        <p>lambda 의 → 다음에는 line break 하지 않는데, lambda body가 single expression 인 경우를 제외하고는 반드시 ( 다음에 line break 해야 한다.</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">MyLambda</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">lambda</span> <span class="o">=</span>
     <span class="o">(</span><span class="n">String</span> <span class="n">label</span><span class="o">,</span> <span class="n">Long</span> <span class="n">value</span><span class="o">,</span> <span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
         <span class="o">...</span>
     <span class="o">};</span>

 <span class="n">Predicate</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">predicate</span> <span class="o">=</span> <span class="n">str</span> <span class="o">-&gt;</span>
     <span class="n">longExpressionInvolving</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>line-wrapping 이후에는 +4 만큼의 들여쓰기를 한다.</li>
</ul>

<h3 id="2-6-공백-whitespace">2-6 공백 Whitespace</h3>

<ol>
  <li>Vertical Whitespace
    <ul>
      <li>다음과 같은 경우 빈 줄이 들어간다.
        <ol>
          <li>consecutive members 나 initializers of a class 사이에 빈 줄
            <ul>
              <li>필드, constructors, methods, nested classes, static initializer, instance initializer</li>
              <li>두 필드 사이에 공백은 선택이다.</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>빈 줄은 가독성을 위해서 필요한 곳에 어디든 추가될 수 있다.</li>
    </ul>
  </li>
  <li>Horizontal whitespace
    <ol>
      <li>if, for, catch 뒤에 있는 ‘(‘ 사이에 공백</li>
      <li>else, catch 앞에 있는 ‘}’ 사이에 공백</li>
      <li>’{‘ 앞에 공백.
        <ul>
          <li>예외1: annotation 안에 있는 ‘{‘ 앞에는 공백 없음</li>
          <li>배열 안에 원소로 인한 ‘{‘ 앞에는 공백 없음</li>
        </ul>
      </li>
      <li>binary 나 ternary operator 앞 뒤로 공백 넣는다.
        <ul>
          <li>&lt;T extends Foo &amp; Bar&gt;</li>
          <li><code class="highlighter-rouge">catch (FooException | BarException e)</code></li>
          <li><code class="highlighter-rouge">(String str) -&gt; str.length()</code></li>
          <li>(::) 이나 (.) 앞 뒤에는 공백 없음</li>
        </ul>
      </li>
      <li>,:; 나 ‘)’ 뒤에 공백 있음.</li>
      <li>변수이름과 type 사이에 공백: List<String> list</String></li>
    </ol>
  </li>
</ol>

<p><br /></p>

<h2 id="3-naming">3. Naming</h2>

<h3 id="3-1-package-names">3-1. Package names</h3>

<ol>
  <li>패지키 이름은 Camel Case도 아니고 전부 소문자로 띄어쓰기 없이 이루어진다.</li>
</ol>

<h3 id="3-2-class-names">3-2. Class names</h3>

<ol>
  <li>클래스 이름은 UpperCamelCase로 이루어 진다.</li>
  <li>주로 noun이나 noun phase이다.</li>
  <li>Test 클래스의 경우 뒤에 Test가 붙는다.</li>
</ol>

<h3 id="3-3-method-names">3-3 Method names</h3>

<ol>
  <li>메소드 이름은 lowerCamelCase로 나타난다.</li>
  <li>주로 verb 이다.</li>
</ol>

<h3 id="3-4-constant-names">3-4 Constant names</h3>

<ol>
  <li>상수의 경우 CONSTANT_CASE 와 같이 전부 대문자, _ 로 구분되어 있다.</li>
  <li>여기서 상수라고 하는 것은 static final field 이며, 잘 변하지 않고, 메소드에 이거에 의한 부작용이 없는 숫자를 말한다.</li>
  <li>
    <p>예시:</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// Constants</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NUMBER</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">NAMES</span> <span class="o">=</span> <span class="n">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Ed"</span><span class="o">,</span> <span class="s">"Ann"</span><span class="o">);</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">AGES</span> <span class="o">=</span> <span class="n">ImmutableMap</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Ed"</span><span class="o">,</span> <span class="mi">35</span><span class="o">,</span> <span class="s">"Ann"</span><span class="o">,</span> <span class="mi">32</span><span class="o">);</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">Joiner</span> <span class="n">COMMA_JOINER</span> <span class="o">=</span> <span class="n">Joiner</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="sc">','</span><span class="o">);</span> <span class="c1">// because Joiner is immutable</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">SomeMutableType</span><span class="o">[]</span> <span class="n">EMPTY_ARRAY</span> <span class="o">=</span> <span class="o">{};</span>
 <span class="kd">enum</span> <span class="n">SomeEnum</span> <span class="o">{</span> <span class="n">ENUM_CONSTANT</span> <span class="o">}</span>

 <span class="c1">// Not constants</span>
 <span class="kd">static</span> <span class="n">String</span> <span class="n">nonFinal</span> <span class="o">=</span> <span class="s">"non-final"</span><span class="o">;</span>
 <span class="kd">final</span> <span class="n">String</span> <span class="n">nonStatic</span> <span class="o">=</span> <span class="s">"non-static"</span><span class="o">;</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">mutableCollection</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">SomeMutableType</span><span class="o">&gt;</span> <span class="n">mutableElements</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">mutable</span><span class="o">);</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">SomeMutableType</span><span class="o">&gt;</span> <span class="n">mutableValues</span> <span class="o">=</span>
     <span class="n">ImmutableMap</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Ed"</span><span class="o">,</span> <span class="n">mutableInstance</span><span class="o">,</span> <span class="s">"Ann"</span><span class="o">,</span> <span class="n">mutableInstance2</span><span class="o">);</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">MyClass</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
 <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">nonEmptyArray</span> <span class="o">=</span> <span class="o">{</span><span class="s">"these"</span><span class="o">,</span> <span class="s">"can"</span><span class="o">,</span> <span class="s">"change"</span><span class="o">};</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="3-5-non-cnastant-field-names">3-5 Non-cnastant field names</h3>

<ol>
  <li>Non-constant field(static 이거나 아니거나)의 경우 lowerCamelCase로 되어 있다. 주로 noun 이다.</li>
</ol>

<h3 id="3-6-이외의-다른-camelcase">3-6 이외의 다른 CamelCase</h3>

<ol>
  <li>Parameter, local variable, type variable 모두 lowCamelCase로 쓴다.</li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA] ArrayList와 LinkedList 차이점</title>
	  <link>//java-list</link>
	  <author></author>
	  <pubDate>2020-08-09T10:18:00+00:00</pubDate>
	  <guid>//java-list</guid>
	  <description><![CDATA[
	     <p><br /></p>

<p>자바에서 LIST 인터페이스를 구현한 Collection 구현체 중 가장 많이 쓰고 헷갈리는 것이 ArrayList와 LinkedList의 차이이다. 알고리즘 코딩을 공부하다가 특정 답을 배열 구조에 담을 일이 있어서 찾아보다 문득 ArrayList, LinkedList 중 무엇을 쓸까 고민하는 김에 정리하게 되었다.</p>

<p>인터페이스도 같고 사용하는 방식도 비슷한 부분이 많기 때문에 ArrayList를 써야할 때 LinkedList를 쓰거나 그 반대로 사용하더라도 큰 차이가 없이 느껴지기도 한다. 하지만 두 가지 자료구조가 구분되어 있는 만큼 더 적절한 부분이 있다. 간단히 한번 알아보자.</p>

<p>Java에서는 변수를 저장하기 위해서 배열을 사용한다. 하지만 배열의 단점은 초기에 길이를 저장해서 미리 메모리를 확보해 놓아야 한다는 것이다. 다라서 동적으로 메모리 할당이 어려울 뿐만 아니라, 예상하지 못하는 입력크기에 대해서는 애초에 크게 배열의 크기를 잡아놓는 비효율적인 방법을 택해야 한다. 이런 문제를 해결할 수 있도록 자바 Collection에서는 ArrayList와 LinkedList 자료구조를 제공한다.</p>

<h3 id="arraylist">ArrayList</h3>

<p>ArrayList는 데이터를 배열로 관리하고 데이터를 추가, 삭제하기 위해서 임시 배열을 생성해서 데이터를 복사하여 하나씩 index를 모두 미룬다.</p>

<p>다르게 말하면 많은 양의 데이터를 추가/삭제하는 경우에는 복사가 매우 많이 일어나게 되며, 그만큼의 성능저하를 일으킨다. 하지만 ArrayList가 LinkedList에 비해서 유용하게 작동하는 부분은 바로 탐색이다. 각 데이터는 각자의 인덱스를 가지고 있기 때문에 참조를 할 때 한번에 참조가 가능하며 매우 유리하게 작동하는 구현체가 된다.</p>

<h3 id="linkedlist">LinkedList</h3>

<p>LinkedList는 각 노드가 자기 이전의 노드와 다음 노드를 알고 있다. 따라서 데이터를 추가하고 삭제할 시, 위에서 보이는 것처럼 그 앞과 뒤의 연결만 신경쓰면 되기 때문에 매우 유용하다. 하지만 탐색의 경우 각 노드가 정해진 인덱스에 저장되어 있는 것은 아니기 때문에 처음부터 순차적으로 노드를 방문해서 검색해야 한다는 단점을 가지고 있다.</p>

<h3 id="데이터-검색삽입삭제-성능-비교">데이터 검색/삽입/삭제 성능 비교</h3>

<h5 id="검색">검색</h5>

<p>검색은 ArrayList가 LinkedList에 비해 훨씬 빠르다. ArrayList는 인덱스 기반으로 바로 해당 인덱스를 참조할 수 있기 때문에 O(1)의 시간 복잡도를 가진다. 그에 비해 LinkedList는 검색 시 모든 요소 탐색을 하기 때문에 최악의 경우 O(n)의 시간 복잡도를 가진다.</p>

<h5 id="삽입삭제">삽입/삭제</h5>

<p>LinkedList의 삽입, 삭제는 ArrayList에 비해서 빠른데 LinkedList는 앞뒤 노드의 참조 형태만 변경하면 되기 때문에 따라서 삽입과 삭제가 일어날 때 O(1)의 시간 복잡도를 가지는 반면 ArrayList는 O(n)의 시간복잡도를 가진다.</p>

<h3 id="코드-응용에서의-성능-비교">코드 응용에서의 성능 비교</h3>

<p>알고리즘 문제를 풀 때, 각 문제에 대한 정답을 배열에 저장하여 한꺼번에 출력을 해야하는 문제가 있었다. 해당 문제에서는 각 문제에 대해서 매번 그 답을 삽입해야 하기 때문에 LinkedList가 훨씬 좋은 성능을 보였다.</p>

<p>예를 들어 다음과 같은 코드를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">link</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

<span class="c1">//어떠한 조건이 충족되었을 때, </span>
<span class="n">arr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'-'</span><span class="o">);</span>
<span class="n">link</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'-'</span><span class="o">);</span>

<span class="c1">//댜른 조건이 충족되었을 때,</span>
<span class="n">arr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'+'</span><span class="o">);</span>
<span class="n">link</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="sc">'+'</span><span class="o">);</span>
</code></pre></div></div>

<p>크게 중요하지 않기 때문에 전체 코드를 적지는 않았다. 대충 위와 같은 코드에서 각각 ArrayList와 LinkedList로 비교해보았을 때 다음과 같은 성능 차이를 보였다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/113716079-2d07c480-9725-11eb-99d8-f9696839f3d6.png" alt="result" /></p>

<p><img src="https://user-images.githubusercontent.com/63405904/113716079-2d07c480-9725-11eb-99d8-f9696839f3d6.png" style="zoom:80%;" /></p>

<p>첫번째 나온 라인이 LinkedList을 사용했을 때 1700ms 의 시간 효율을 보였고, 동일한 코드에 ArrayList를 사용했을 때, 잦은 삽입으로 다소 낮은 2056ms의 시간 효율을 보인 것을 볼 수 있다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>[Java] Wrapper Classes in Java</title>
	  <link>//java-wrapper-class</link>
	  <author></author>
	  <pubDate>2020-08-08T10:18:00+00:00</pubDate>
	  <guid>//java-wrapper-class</guid>
	  <description><![CDATA[
	     <p><br /></p>

<p>다음은 Java에 존재하는 아주 특이한 클래스인 Wrapper class에 대한 내용이다. JAVA wrapper class에 대해서 설명한 한 &lt;a href=https://www.baeldung.com/java-wrapper-classes&gt;사이트&lt;/a&gt;를 <strong>번역</strong>하는 겸 공부한 내용을 정리해 작성해놓았다.</p>

<h2 id="1-개요">1. 개요</h2>

<p>Wrapper class(감싸는 클래스) 이름이 설명하듯이 wrapper class는 자바의 Primitive types들을 객체로 감싸는 역할을 하는 클래스이다.</p>

<p>다음과 같은 자바의 primitive 타입들은 모두 각자의 wrapper 클래스가 있다.</p>

<ul>
  <li>boolean, byte, short, char, int, long, float, double</li>
  <li>Boolean, Byte, Short, Character, Integer, Long, Float, Double</li>
</ul>

<p>이것들은 모두 java.lang 패키지에 정의되어 있으므로 따로 import 하지 않아도 사용할 수 있다.</p>

<h2 id="2-wrapper-classes">2. Wrapper Classes</h2>

<p>“Wrapper 클래스의 목적은 무엇입니까?”는 자바 관련 인터뷰에서 흔하게 물어보는 질문 중 하나이다.</p>

<p>그 목적은 간단하게 말해서, generic classes는 객체와 호환되서 작동되지 primitive 타입과는 호환이 되지 않기 때문이다. 따라서, 우리가 generic classe들을 사용하고 싶다면 우리는 primitive type들을 객체로 만들 수 있도록 하는 방법이 필요한 것이다.</p>

<p>예를 들어서, 많은 유용한 기능들을 제공하는 Java Collection Framwork는 객체와만 작동하도록 되어 있다. Java 버전 5 이하, 즉 거의 15년 전 자바를 사용할때는 나중에 소개할 autoboxing 기능이 없었기 때문에 현재 사용되는 것처럼 간단히 <code class="highlighter-rouge">add(5)</code> 와 같이 collection of Integers를 사용할 수 없었다.</p>

<p>당시에는 primitive 타입의 값들은 직접 각 wrapper classes로 변환되어 새롭게 저장되어야 사용될 수 있었다. 지금은 autoboxing이라는 기능이 추가되면서, <code class="highlighter-rouge">ÀrrayList.add(101)</code>와 같은 문법을 그대로 사용할 수 있다. 자바 내부적으로 primitive value들을 Integer등과 같은 wrapper class 객체로 변환해서 사용될 수 있도록 하기 때문이다.</p>

<h2 id="3-primitive에서-wrapper-class로-변환">3. Primitive에서 Wrapper Class로 변환</h2>

<p>그럼 이 시점에 나올 만한 질문은 “어떻게 primitive value를 해당 타입 wrapper class로 변환할 수 있는가? “이다. 예를 들어, int 를 Integer로 변환하고, char를 Character로 변환하는 방법은 무엇인가 이다.</p>

<p>간단히 2가지 방법이 있다. 생성자 constructor를 사용하던지, static factory method를 사용해서 primitive value를 wrapper class로 변환할 수 있다.</p>

<p>하지만 Java 9에 들어서는 Integer나 Long에 대한 생성자는 중요도가 떨어지면 지원되지 않는 경우가 많기 때문에 factory method를 사용하는 것을 높이 권장한다. 다음 코드를 참고해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Integer</span> <span class="n">object</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//생성자 사용</span>

<span class="n">Integer</span> <span class="n">another</span> <span class="n">Object</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//factory method 사용</span>
</code></pre></div></div>

<p>위의 코드에 <code class="highlighter-rouge">valueOf()</code>메소드는 int를 Integer 객체로 변환해여 반환한다. 캐싱된 값을 반환하기 때문에 매우 효율적이고, -128 에서 127까지의 값은 항상 캐싱하며 이 범위 박의 값들도 캐싱할 수 있는 장점을 가지고 있다.</p>

<p>위의 방법관 같이 boolean을 Boolean으로, byte 를 Byte, chat를 Character로, long을 Long으로, float을 Float로, double을 Double로 변환할 수 있다. 이와 다르게 String을 Integer로 변환하고 싶을 때는 String이 wrapper class가 아니기 때문에 <code class="highlighter-rouge">parseInt()</code> 를 사용해야 한다.</p>

<p>반대로 wrapper 객체를 다시 Primitive type으로 변환하고 싶을 때는 각자에 맞는 <code class="highlighter-rouge">intValue()</code> 나 <code class="highlighter-rouge">doubleValue()</code> 와 같은 메소드를 사용해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">object</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="4-autoboxing-과-unboxing">4. Autoboxing 과 Unboxing</h2>

<p>이전 파트에서는 어떻게 primitive 값을 객체로 매뉴얼하게 바꿀 수 있는지에 대해서 다뤘었다. 하지만 이전에 언급했듯이 Java 5 이후에는 자동으로 변환해주는 autoboxing, unboxing이라는 속성이 등장했다.</p>

<p>“Boxing”이라는 뜻이 primitive value를 해당 Wrapper class로 변환해준다는 의미이다. 자동적으로 변환되기 때문에 다음 단어에 auto를 덧붙여서 autoboxing이라고 불린다.</p>

<p>비슷한 경우로 wrapper 객체가 unwrapped 되어 다시 primitive value가 되는 개념이 unboxing이다.</p>

<p>즉, autoboxing과 unboxing은 실전에서 사용될 때 사용자가 primitive value를 특정 메소드에서 사용할 때 wrapper object이나 해당 primitive을 기대한 객체의 타입으로 바꾸어 준다는 뜻이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//autoboxing</span>

<span class="n">Integer</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="c1">//autoboxing</span>
</code></pre></div></div>

<p>위의 예시에서는 자바가 자동적으로 primitive value인 int를 wrapper로 변환해주었다. 사실, 내부적으로는 valueOf() 메소드를 사용해서 변환한 것이다. 예를 들어, 다음 두 코드는 동일하게 동작하는 것이라고 여겨진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Integer</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>

<span class="n">Integer</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
</code></pre></div></div>

<p>autoboxing은 코드를 한결 간결하게 만들어주고, 가독성을 높여주지만 때로는 <strong>사용하지 말아야 할 때</strong>가 있다. 예를 들어 <strong>반복문 안</strong>에서는 사용하지 않도록 한다.</p>

<p>Autoboxing과 비슷하게 unboxing 또한 객체를 어떤 메소드에 전달했을 때 자동으로 기대되는 primitive로 변화해주는 역할을 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Integer</span> <span class="n">object</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">getSquareValue</span><span class="o">(</span><span class="n">object</span><span class="o">);</span> <span class="c1">//unboxing</span>
<span class="kt">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">object</span><span class="o">;</span> <span class="c1">//unboxing</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getSquareValue</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">){</span>
  <span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>즉, 어떠한 메소드가 primitive value나 wrapper object을 기대할 때 두 가지 경우 모두를 전달할 수 있다는 것이다. 자바가 내부적으로 전달받은 변수에 대해서 맞는 primitive나 wrapper 클래스로 변환해 줄 것이기 때문이다.</p>

<p><strong><small>[참고 자료]: https://www.baeldung.com/java-wrapper-classes, https://www.geeksforgeeks.org/wrapper-classes-java/</small></strong></p>


	  ]]></description>
	</item>

	<item>
	  <title>[JAVA] 유용 문법 모음</title>
	  <link>//about-java</link>
	  <author></author>
	  <pubDate>2020-08-03T10:18:00+00:00</pubDate>
	  <guid>//about-java</guid>
	  <description><![CDATA[
	     <p><br /></p>

<blockquote>
  <p>Java를 사용해서 코딩 테스트 준비 겸 알고리즘 문제를 풀어보다 알아두면 유용한 자바 문법이나 코드 등등을 맥락없이 적어놓는 메모장 같은 페이지.</p>
</blockquote>

<h2 id="stringbuilder--stringbuffer">StringBuilder &amp; StringBuffer</h2>

<p>알고리즘은 맞지만 시간초과가 걸릴 때 유용함.</p>

<ul>
  <li>String 변수에 ‘+’ 연산자를 써서 이어붙이면 매번 새로운 메모리를 할당하기 때문에 시간초과가 걸림.</li>
  <li>StringBuilder 를 사용하면 동일한 메모리에 append 하므로 시간측면에서 유용함.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"Hello "</span><span class="o">);</span>
<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"My name is Yun"</span><span class="o">);</span>
<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="bufferedreader">BufferedReader</h2>

<ul>
  <li>
    <p>Scanner를 사용하여서 많은 데이터를 입력할 때 시간초과가 일어나기도 함.</p>
  </li>
  <li>
    <p>한꺼번에 버퍼에 저장했다가 한번에 읽어드리는 BufferedReader가 확연히 빠르게 동작함.</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
    <span class="n">String</span> <span class="n">input</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
    
    <span class="k">try</span><span class="o">{</span>
      <span class="n">input</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">){}</span>
    <span class="n">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">paresInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
    
    <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
    
</code></pre></div></div>

<ul>
  <li>BufferedReader는 항상 try-catch를 사용해서 읽음.</li>
  <li>한줄 씩 밖에 읽을 수 없고, 반드시 String으로 들어오기 때문에 입력 데이터에 대한 가공이 필요함.
    <ul>
      <li>StringTokenizer로 원하는 문자 기준으로 나눌 수 있음.</li>
      <li>Integer.parseInt를 사용하여 스트링을 정수로 변함.</li>
      <li>반드시 close() 해주어야 함.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="iterator">Iterator</h2>

<ul>
  <li>여러모로 유명하고 유용하나 Stack등에 대한 자료구조에 있어서 pop을 하지 않고 데이터 처음부터 읽을 수 있음.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Iterator</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
    <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
    
    <span class="n">Iterator</span> <span class="n">value</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="자바-2차원-배열-정렬하기">자바 2차원 배열 정렬하기</h2>

<p>자바에서는 Arrays.sort() 함수를 통해서 손쉽게 배열을 정렬할 수 있다. 하지만 Comparator를 상속 받아서 배열을 정렬하는 이 메소드를 제대로 이해하기 위해서는 상속받은 Comparator 인터페이스의 성질과 override 하고 있는 메소드 들에 대해서 잘 이해하는 것이 좋다.</p>

<p>다음을 자바에서 2원 배열을 먼저 1번째 원소에 대해서 정렬하고, 1번째 원소가 같을 때 2번째 원소의 값에 대해서 정렬하는 것에 대한 코드이다. 알고리즘 문제를 풀면서 다차원 배열을 정렬할 때 매우 유용하므로 기록한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
    
    <span class="c1">//위의 2차원 배열 arr에 대해서 1번째 원소에 대해서 정렬하고, 같다면 2번째 원소에 대해서 정렬하기</span>
    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;(){</span>
      <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">t1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">t2</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">t2</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
          <span class="k">return</span> <span class="n">t1</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">t2</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">else</span>
          <span class="k">return</span> <span class="n">t1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">t2</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
      <span class="o">}</span>
    <span class="o">});</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="자바-배열-복사하기">자바 배열 복사하기</h2>

<p>자바에서는 배열을 복사할 때 2가지로 나뉜다. 배열이 모두 주소값으로 지정이된다는 것은 모두 알 것이다. 그때 중요한 것은 배열을 다음 두가지 중 어떠한 복사를 할 것인지 이다.</p>

<p><strong>1. Shallow copy (얕은 복사)</strong></p>

<ul>
  <li>복사를 했을 때 주소가 가리키는 것만 바꿈.</li>
  <li>source의 배열이 변경되면 해당 배열 또한 같은 주소를 가지고 있으므로 함께 변경됨.</li>
</ul>

<h5 id="java-에서의-얕은-복사">JAVA 에서의 얕은 복사</h5>

<p>&lt;img src=”https://user-images.githubusercontent.com/63405904/113480037-44e50b80-94cd-11eb-9660-d61e6222f44e.png” width=70% /&gt;</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
</code></pre></div></div>

<p><strong>2. Deep copy (깊은 복사)</strong></p>

<ul>
  <li>복사를 했을 때, 새로운 배열이 생성되어 동일한 값 다른 주소를 가진 배열이 생성됨</li>
</ul>

<p>&lt;img src=”https://user-images.githubusercontent.com/63405904/113480050-4dd5dd00-94cd-11eb-810e-b3a34710a5c3.png” width=70% /&gt;</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
  <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h6 id="java에서-배열-복사를-위한-메서드">JAVA에서 배열 복사를 위한 메서드</h6>

<ol>
  <li><code class="highlighter-rouge">Object.clone()</code></li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</code></pre></div></div>

<p>깊은 복사의 가장 보편적인 방법임. <em>하지만 객체나 2차원 배열에는 해당되지 않음.</em></p>

<ol>
  <li><code class="highlighter-rouge">Arrays.copyOf()</code></li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</code></pre></div></div>

<p>배열의 시작점부터 원하는 length 까지 깊은 복사를 할 수 있음.</p>

<ol>
  <li><code class="highlighter-rouge">Arrays.copyOfRange()</code></li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</code></pre></div></div>

<p>배열을 복사할 시작점 또한 정의할 수 있음.</p>

<ol>
  <li><code class="highlighter-rouge">System.arraycopy()</code></li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
<span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</code></pre></div></div>

<p>지정된 배열을 대상 배열의 지정된 위치에 복사할 수 있음.</p>

<p><br /></p>

<h4 id="2차원-배열의-깊은-복사">2차원 배열의 깊은 복사</h4>

<p>1차원 배열은 위의 메소드를 사용할 수 있지만 2차원 배열의 경우 해당되지 않는다.</p>

<p>2차원 배열의 경우 y좌표를 가리키는 주소 값만 있는 a[x] 부분만 깊은 복사가 되므로 다음 2가지 방법을 사용해야 한다.</p>

<ol>
  <li>이중 for문</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="o">[][]</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,},</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">}</span> <span class="o">};</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
	    
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>  
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ol>
  <li><code class="highlighter-rouge">System.arraycopy</code></li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="o">[][]</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">},</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">}</span> <span class="o">};</span>
<span class="kt">int</span> <span class="n">b</span><span class="o">[][]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
	    
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
  <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="comparator-사용">Comparator 사용</h2>

<p>위에서 2차원 배열을 정렬할 때 잠깐 언급하기는 했지만, 어떠한 클래스 변수등에 대해서 특별한(흔치 않은) 기준으로 정렬을 하고 싶을 때 사용하기 좋은 자바 문법이다.</p>

<p>어떤 기준으로 더 작으면 음수, 같으면 0, 더 크다면 양수를 리턴하여 정렬을 할 수 있도록 해주는 역할을 한다.</p>

<p>주로 객체를 정렬할 때 유용하게 사용된다.</p>

<ol>
  <li>Class 로 따로 만들어서 <code class="highlighter-rouge">new</code>를 통해서 생성하여 사용할 수 있다.</li>
  <li>main 안에서 하나의 변수처럼 만들어서 적용할 수 있다.</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
  <span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
  
  <span class="n">arr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p1</span><span class="o">);</span>
  <span class="n">arr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p2</span><span class="o">);</span>
  
  <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="k">new</span> <span class="n">xComparator</span><span class="o">());</span> <span class="c1">//1번 경우</span>
  
  <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">yComparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Point</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Point</span><span class="o">,</span> <span class="n">p2</span><span class="o">){</span>
      <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">p2</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">};</span>
  
  <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">yComparator</span><span class="o">);</span> <span class="c1">//2번 경우</span>
  
  <span class="k">return</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">xComparator</span> <span class="kd">implements</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Point</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Point</span> <span class="n">p2</span><span class="o">){</span>
    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">p2</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Point</span><span class="o">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


	  ]]></description>
	</item>

	<item>
	  <title>[JAVA] String vs. StringBuilder vs. StringBuffer</title>
	  <link>//java-string</link>
	  <author></author>
	  <pubDate>2020-07-19T10:18:00+00:00</pubDate>
	  <guid>//java-string</guid>
	  <description><![CDATA[
	     <p><br />
코딩 연습을 하면서 백준 알고리즘 문제를 풀다가 재귀에 대해서 복습할 겸 백준 하노이 타워 문제를 풀었는데 시간초과 오류가 떴다. <small> <a href="https://www.acmicpc.net/problem/11729">문제 바로가기</a> </small></p>

<p>하노이 탑은 매우 단순한 논리이고, 이전에 했던 것을 복습하는 차원에서 반복하는 것이었기 때문에 시간초과 오류가  떠서 의아했다. 여기저기 찾아본 결과 output을 출력하는데 String 변수에 <mark>+</mark> 를 사용하여서 이어 붙여 결과값을 출력했더니 시간초과가 발생했다고 한다. 그럼 String 변수는 왜 시간 초과를 발생시키며, 해결할 수 있는 방법은 뭘까?</p>

<p>자바를 배운지는 오래 되었지만 한번도 Java api 를 들여다 본 적은 없는데 거기서 확인해보면 java.lang의 패키지의 Class 중, String 이외에도 <strong>StringBuffer, StringBuilder</strong>가 있는 것을 확인할 수 있다.</p>

<p><strong><small>Java 개발자라면 익숙한 class 들을 고민 없이 쓰기 보다 고민하여 효율적인 것을 택해보자!</small></strong></p>

<hr />

<h3 id="string-vs-stringbuffer-vs-stringbuilder">String vs. StringBuffer vs. StringBuilder</h3>

<p>다음은 Java API에서 찾은 String, StringBuffer, StringBuilder class 내용이다. 매우 방대한 내용을 담고 있으니 존재하고 있다는 것만 인증하고 넘어가보자.</p>

<p>&lt;img src=”https://user-images.githubusercontent.com/63405904/113874297-9dc7e300-97f0-11eb-9525-8538f6c91ff5.png” width=60%/&gt;</p>

<p>&lt;img src=”https://user-images.githubusercontent.com/63405904/113874434-c18b2900-97f0-11eb-9d64-d2a9910dea23.png” alt=String Class width=40% /&gt;</p>

<p>&lt;img src=”https://user-images.githubusercontent.com/63405904/113874481-ccde5480-97f0-11eb-9546-d366c2923b2e.png” alt=String Class width=40% /&gt;</p>

<p>API의 초반만 살펴보면 String과 나머지 두 class의 차이는 별로 없어보인다. 하지만 자바에서 String을 사용할 때, 값을 추가하고 싶거나 이어붙이고 싶을 때 간편하게 + 를 사용하여서 이어붙인다. 하지만 이렇게 이어 붙이기 보다 StringBuilder, StringBuffer를 사용하라고 한다. <em>왤까?</em></p>

<p>자, 다음 코드를 들여다 보자. 이제는 돌아가는 코드가 아니라 <em>효율적인 코드</em>에 집중하는 <strong>프로</strong>다움을 발휘 할 때이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">"one"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">"two"</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str1: "</span><span class="o">+</span> <span class="n">str1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str2: "</span><span class="o">+</span> <span class="n">str2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>

<span class="n">str1</span> <span class="o">=</span> <span class="n">str1</span><span class="o">+</span><span class="n">str2</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str1: "</span><span class="o">+</span> <span class="n">str1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>

<span class="n">StringBuffer</span> <span class="n">str3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBugger</span><span class="o">();</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str3: "</span><span class="o">+</span> <span class="n">str3</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>

<span class="n">str3</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"three"</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str3: "</span><span class="o">+</span> <span class="n">str3</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>

<span class="o">&gt;</span><span class="nl">RESULT:</span>
	<span class="nl">str1:</span> <span class="o">-</span><span class="mi">1823841245</span>
  <span class="nl">str2:</span> <span class="o">-</span><span class="mi">1823841244</span>
  <span class="nl">str1:</span> <span class="mi">833872391</span>
  <span class="nl">str3:</span> <span class="mi">1956725890</span>
  <span class="nl">str3:</span> <span class="mi">1956725890</span>

</code></pre></div></div>

<p>위 코드를 확인해보면, String 클래스로 정의한 str1 과 str1 는 새로운 값을 할당할 때마다 주소값이 새로 생성된다. str1에 str2를 <strong>’+’</strong>를 사용해서 이어붙였을 때에도 또 새로운 주소가 생성되었다. 하지만 StringBuffer 클래스를 사용하여서 생성하고, memory에 append 하는 방식으로 문자열을 추가하였을 때 동일한 주소값을 사용하는 것을 확일할 수 있다.(즉, 클래스를 직접생성하는 것이 아님.) <strong>StringBuffer나 StringBuilder 클래스를 사용할 때는 String 클래스를 생성할 때 method와 variable들을 생성하면서 소요되는 시간이 단축된다.</strong></p>

<p>이것이 문제를 재귀함수로 풀때 수십 번을 넘어서 수백 번 String을 더하면서 해당 수많은 주소값이 Stack에 쌓이며 시간과 메모리를 낭비하여서 시간초과 오류가 떴던 것이다.</p>

<hr />

<h3 id="string-class는-새로운-주소를-할당">String Class는 새로운 주소를 할당</h3>

<p>그렇다면 왜 String class는 새로운 주소를 할당하는 것일까? Java에서 제공하는 String 클래스의 내부코드를 들여다보면 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">String</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span><span class="o">,</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;,</span> <span class="n">CharSequence</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">chat</span> <span class="n">value</span><span class="o">[];</span> 
  <span class="o">...</span>
  <span class="o">...</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>즉, String은 사실 value라는 char 형 배열이고 private final char 형으로 선언이 되어 있다. 여기서 private으로 보호되고 있고 final로 변경이 불가능하기 때문에 String에 추가할 때 사실은 변경이 되는 것이 아니라 새로운 주소에 새로 저장하는 원리로 작동하고 있는 것이다.</p>

<hr />

<h3 id="stringbuffer-vs-stringbuilder">StringBuffer vs. StringBuilder</h3>

<p>그렇다면 나의 경우 하노이 문제를 풀 때 StringBuffer와 StringBuilder 중 어떤 것을 사용해야하는 걸까? 두 클래스의 차이를 한번 살펴보자.</p>

<p>&lt;img src=”https://user-images.githubusercontent.com/63405904/113874560-e4b5d880-97f0-11eb-9128-09b7516f2a48.png” width=70% /&gt;</p>

<p>&lt;img src=”https://user-images.githubusercontent.com/63405904/113874646-f9926c00-97f0-11eb-8db4-143c02f89102.png” width=70% /&gt;</p>

<p>관련된 사항이 있는 API 문서 부분에 빨간색으로 밑줄을 쳐 놓았다. 보면 StringBuffer는 synchronization을 하기 때문에 Multi-thread 환경에서 사용하고 있다면 더 안전하다. StringBuilder는 반면 <em>‘multiple threads에서는 안전하지 않다’</em> 라고 분명히 명시해 놓으면서 synchronization을 하지 않는다고  명시해 놓았다.<strong><small> (synchronization이 필요하면 반드시 StringBuffer를 사용하라는 당부와 함께 말이다.) </small></strong></p>

<p>단순히 성능만 비교한다면 실험을 통해 다음과 같은 결과를 참고할 수 있다.</p>

<p>&lt;img src=”https://user-images.githubusercontent.com/63405904/113874722-0c0ca580-97f1-11eb-9e31-3509d138eef9.png” width=70% /&gt;</p>

<p>위 표는 각각 StringBuffer와 StringBuilder를 사용하여서 append 를 여러번 반복했을 때 나온 수치이다. Single-thread를 사용했을 때도 StringBuilder의 시간적인 면에서의 성능이 StringBuffer보다 뛰어났다. 이것은 StringBuffer에서 행하는 동기화(Synchronization)에 의한 차이로 해석할 수 있다.</p>

<hr />

<h3 id="결론">결론</h3>

<p>하노이 문제를 해결할 때 필자의 경우 Multi-thread 환경이 아니기 때문에 시간적인 측면에서 더 뛰어난 StringBuilder를 사용해 append 하여 결과를 출력하기로 했다. 결과는 성공이다!</p>

<p><small>[참고자료]: https://novemberde.github.io/2017/04/15/String_0.html, https://www.journaldev.com/538/string-vs-stringbuffer-vs-stringbuilder </small><br /><small>[이미지 출처]: https://docs.oracle.com/javase/7/docs/api/, https://www.journaldev.com/538/string-vs-stringbuffer-vs-stringbuilder </small></p>


	  ]]></description>
	</item>


</channel>
</rss>
