<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>yjksw.github.io/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[머신러닝] 딥러닝 영화 개인화 추천 - Part.1</title>
	  <link>//movie-dlrm-1</link>
	  <author></author>
	  <pubDate>2020-08-21T10:18:00+00:00</pubDate>
	  <guid>//movie-dlrm-1</guid>
	  <description><![CDATA[
	     <p>인턴을 하는 중에 요즘에 중요한 머신러닝의 한 분야가 되고 있는 개인화 추천에 대한 개발을 맡게 되었다. 요즘 넷플릭스, 왓챠와 같은 OTT 서비스는 물론이고, SNS에 표기되는 광고, 당근마켓 등등과 같은 중고거래 및 쇼핑 어플리케이션에서도 중요한 것이 사용자의 취향을 분석하여서 알맞은 아이템을 추천하는 기술이 핵심이다. 어쩌면 사용자가 의식적으로 파악하고 있는 이상의 취향을 파악해서 추천해야 할 때도 있다. 이전 포스트에서 다루었듯이 개인화 추천에는 여러 통계기반 머신러닝 기법들이 있다. 그리고 인공 신경망이라는 딥러닝 기법이 등장하게 되면서 더욱 세밀하고 정확한 개인화 추천이 가능해졌다.</p>

<p>처음 접했기 때문에 매우 생소하고 낯선 분야였지만 많은 자료들을 찾아보면서 현재 내 삶(<small>유튜브나 넷플릭스의 노예…</small>)과 아주 밀접하게 연관이 되어 있는 많은 어플리케이션과 서비스등에 실제로 사용되고 있는 인공지능 기법이라는 것이 금방 흥미를 불러 일으켰다. 조금 어렵긴 하지만 facebook에서 공개한 DLRM(Deep Learning Recommendation Model) <a href="https://ai.facebook.com/blog/dlrm-an-advanced-open-source-deep-learning-recommendation-model/">자료</a>나 구글에서 공개한 유튜브 개인화 추천 <a href="https://research.google/pubs/pub45530/">논문</a>, 국내의 당근마켓에서 쓴 개인화 추천 관련 블로그 <a href="[https://medium.com/daangn/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EA%B0%9C%EC%9D%B8%ED%99%94-%EC%B6%94%EC%B2%9C-1eda682c2e8c](https://medium.com/daangn/딥러닝-개인화-추천-1eda682c2e8c)">포스트</a> 등을 참고하면서 개인화 추천에 대한 대략적인 아이디어나 개념을 잡았다. <small>물론 매우 매우 어렵기 때문에 모든 것을 이해하는 것은 (나는) 힘들다. 가볍지만 꼼꼼하게 읽으면서 대략적인 맥락을 파악하는 것을 추천한다!</small></p>

<p>이후에 구현되어 있었던 pytorch를 활용한 딥러닝 모델 예시를 보게 되었고 참고하여 응용하면서 아주 간단한 딥러닝 영화 개인화 추천 모델을 구현하였다. 이번 포스트는 해당 개발의 초반, 데이터 전처리에 관한 내용을 다룰 예정이다. 전체 코드를 보고 싶다면 다음 <a href="https://github.com/yjksw/DeepLearning_Movie_Recommendation_System">github repo</a>를 참고하시길.</p>

<h3 id="데이터-모양새">데이터 모양새</h3>

<p>딥러닝 개인화 추천 모델 구현을 시작하면서 가장 먼저 한 일은 입력 데이터의 형식에 대해서 파악한 것이다. 본 모델을 사용자와 영화 아이템, 그리고 해당  영화에 대한 각 사용자의 ratings 데이터를 담고 있는 MovieLens 데이터를 사용하였다. 해당 사이트에 가서 원하는 파일을 다운받아서 열면 다음과 같은 형식으로 데이터가 담겨져 있다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/110306953-c027de80-8041-11eb-838e-1ca3bf9957f2.png" alt="image" /></p>

<p>해당 csv. 파일을 읽어서 validation 과 test 데이터를 나누어야 한다. 다음 명령어를 써서 읽은 csv 파일 data frame에 대한 마스크를 씌울 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.8</span>
</code></pre></div></div>

<p>나는 구현할 때 80% 정도의 데이터를 학습 데이터로, 나머지 20%의 데이터를 검증 데이터로 사용했다.</p>

<h3 id="데이터-전처리">데이터 전처리</h3>

<p>데이터 전처리에서 해야할 일들은 매우 간단하다. 기본적으로 학습 데이터와 검증 데이터는 모두 비슷한 과정의 데이터 전처리 과정을 거치지만 개인화 추천을 위한 영화 데이터에 대해서 구현할 때는 검증 데이터 전처리에 관해 조금 다른 부분이 필요하기도 하다.</p>

<p>학습에서 사용되는 데이터는 ratings.csv 파일에서도 특히 <em>userId</em>와 <em>movieId</em> 부분이다. 따라서 해당 column를 하나씩 끌어다가 전처리를 해주어야 한다. 여기서 필요한 전처리 과정은 다음과 같다.</p>

<ol>
  <li>중복을 제거하여 순수한 유저와 아이템 리스트 갯수 및 리스트 생성</li>
  <li>학습 데이터가 아닌 검증 또는 테스트 데이터일 경우, 학습 데이터에 존재하지 않는 유저와 아이템에 대하여 -1 처리하여 제외</li>
</ol>

<p><strong>1번</strong> 과정이 필요한 이유는 이후에 신경망 layers를 쌓고 임베딩 할 때에 pytorch의 모듈을 사용하여서 임베딩 테이블을 생성해야하기 때문이다. <strong>2번</strong> 과정이 필요한 이유는 검증 또는 테스트 데이터에 학습 데이터로 학습되지 않은 전혀 새로운 유저나 영화가 나왔을 경우, 제대로 예측할 수 없기 때문에 미리 제거해 주는 것이다.</p>

<h3 id="코드">코드</h3>

<p>위의 데이터 전처리를 하기 위해서 유용한 몇가지 파이썬 코드를 소개한다.</p>

<ol>
  <li>데이터 columns의 중복제거</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uni</span> <span class="o">=</span> <span class="n">train_col</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
</code></pre></div></div>

<p>위 메소드는 입력으로 들어온 column에 대해서 중복을 제거한 리스트를 uni 변수에 저장해준다.</p>

<ol>
  <li>존재하지 않는 아이템에 대하여 -1 처리하기</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">name2idx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col</span><span class="p">])</span>
</code></pre></div></div>

<p>여기서 name2idx는 중복이 없는 순수한 유저 또는 아이템 리스트와 해당 index이다. 위와 같은 코드를 실행하면 name2idx에서 해당 col에 있는 x 값이 있다면 해당 값을 가져오고, 그렇지 않다면 -1을 입력하도록 하는 간편한 파이썬 문법이다.</p>

<p>이후에 학습 데이터에 존재하지 않는 유저 또는 아이템이 음수로 들어와 있으니 해당 처리를 다음과 같이하면 제외하고 검증 및 테스트 할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="결과-화면">결과 화면</h3>

<p>위와 같은 데이터 전처리를 끝내면 다음과 같은 전처리된 데이터가 생성된다. 물론 임베딩하는 전처리가 추가로 필요하지만 다음 포스트에서 학습과 함께 다루도록 하겠다. 결과 화면의 데이터는 csv의 데이터와 크게 차이가 없이 지저분한 데이터들을 제외하고 처리해 놓은 데이터라고 생각하면 된다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/110306884-b00fff00-8041-11eb-91f0-51660920fbcf.png" alt="image" /></p>

<p><strong><small> [참고 자료]: https://jyoondev.tistory.com/65 </small></strong></p>


	  ]]></description>
	</item>

	<item>
	  <title>[머신러닝] 추천 시스템 기술</title>
	  <link>//ml-recommendation-system</link>
	  <author></author>
	  <pubDate>2020-08-10T10:18:00+00:00</pubDate>
	  <guid>//ml-recommendation-system</guid>
	  <description><![CDATA[
	     <p>모 기업에서 인턴을 하면서 맡은 업무가 <mark>개인화 추천 모델 구현</mark>이었다. 맡은 업무는 딥러닝 기반의 개인화 추천 모델을 제작하는 것이지만 기존에 회사에서 가지고 있는 추천 시스템의 경우 협업 필터링 등으로 이미 구현이 되어 있었기 때문에 간단히 개인화 추천 시스템에 대한 브리핑을 해주시면서 감을 잡을 수 있도록 해주셨다.</p>

<p>추천 시스템 기술을 처음 접해보면서 어떠한 것인지 공부하며 기록해보려고 한다.</p>

<h3 id="추천이란">추천이란?</h3>

<p>추천이란 간단히 말해서 사용자(user)에게 관심이 있을 것으로 예상이 되는 아이템(item)을 제안하는 것이다. 특정 아이템에 대한 특정 사용자의 선호도 또는 평가를 예측하는 것이 매우 중요하다.</p>

<p>우리가 흔히 생각해 낼 수 있는 추천 시스템은 페이스북과 같은 것에서의 광고 추천, 넷플릭스나 왓챠와 같은 OTT 서비스에서의 영화 추천 시스템이다.</p>

<h3 id="접근-방식">접근 방식</h3>

<p>추천 시스템 기술에서의 접근 방식은 크게 다음과 같은 3가지가 있다.</p>

<ul>
  <li>내용 기반 필터링 (Content-based Filtering)</li>
  <li>협업 필터링 (Collaborative Filtering)</li>
  <li>하이브리드 (Hybrid)</li>
</ul>

<h4 id="1-내용-기반-필터링">1) 내용 기반 필터링</h4>

<p>사용자의 프로필이나 아이템의 content 정보를 이용하는 방법이다. 사용자의 선호도, 취향 등을 파악하는 방법이 핵심이다. 예를 들어, 회원가입 시 사용자에게 선호하는 아이템 또는 분야 등에 대해서 선택하도록 하여 선호도를 파악하여 해당 정보를 기반으로 추천을 한다. 또는 사용자의 과거에 평가한 아이템 분석을 통해서 선호도를 파악할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/110242569-0590d100-7f9a-11eb-8799-e9fe186779e6.jpeg" alt="contentbased" /></p>

<h4 id="2-협업-필터링">2) 협업 필터링</h4>

<p>협업 필터링은 여러 사용자들의 활동, 기호 정보들을 분석하여, 각 사아요자에게 적합한 아이템을 추천하도록 한다. 예를 들어서 사용자 A와 유사하다고 판단되는 사용자 B가 최근 구매한 상품을 사용자 A에게도 추천하도록 하는 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/110242548-f14cd400-7f99-11eb-927e-2e1000c04eba.jpeg" alt="collaborative" /></p>

<h4 id="3-내용-기반-필터링--협업-필터링의-장단점">3) 내용 기반 필터링 &amp; 협업 필터링의 장단점</h4>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>내용 기반 필터링</th>
      <th>협업 필터링</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>장점</td>
      <td>사용자의 명시적인 기호 정보를 직접적으로 반영한다. <br />다른 사용자의 정보나 평가, 행동 등이 필요하지 않다.<br />새로 추가된 아이템에 대한 추천이 가능하다.</td>
      <td>대부분의 경우 추천 성과가 우수하다.<br />잠재적인 특징을 고려하여 다양한 범위의 추천이 가능하다.</td>
    </tr>
    <tr>
      <td>단점</td>
      <td>사용자의 명시적인 프로필 얻기 어려움이 있다.<br />명시적으로 표현된 특징만 다룰 수 있고 잠재적인 것을 캐치하기 어렵다.<br />추천하는 항목이 비슷한 장르에 머무르는 한계가 있다.</td>
      <td>초기 사용자에 대한 믿을만한 추천이 어렵다. Cold start가 존재한다.<br />한번도 평가되지 않은 아이템은 추천 대상에서 제외된다. sparsity, coverage</td>
    </tr>
  </tbody>
</table>

<h4 id="4-하이브리드">4) 하이브리드</h4>

<p>위에서의 내용 기반 필터링과 협업 필터링을 결합하여 사용한다. 결합하는 방식을 다양하기 때문에 어떠한 하이브리드 방식을 택하는지는 매우 광범위 하다. 하지만 간단히 보아서 위의 두가지 방식을 같이 사용함으로 각자의 단점을 보완한다는 장점을 가지고 있다. 다만 시스템적으로 매우 복잡해질 수 있는 단점이 있다.</p>

<h4 id="5-협업-필터링-기술-분류">5) 협업 필터링 기술 분류</h4>

<p>본 기업에서 중점적으로 사용하고 있는 협업 필터링 기술은 다음과 같이 분류된다.</p>

<ul>
  <li>메모리 기반(Memory-based) 협업 필터링
    <ul>
      <li>사용자 또는 아이템 간의 유사도를 계산하고 그것을 바탕을 추천 결과를 생성하는 방식으로 유사도를 계산하는 방식이 매우 중요함.</li>
      <li><strong>대표 알고리즘</strong>: User-based CF / Item-based CF</li>
      <li><strong>장점</strong>: 구현이 간단하고 이해하기 쉬움.</li>
      <li><strong>한계</strong>: 1) 새로운 사용자와 아이템에 대한 cold start 문제 2) Rating matrix의 sparsity 문제 3) 큰 데이터 셋에 대해 제한된 scalability</li>
    </ul>
  </li>
  <li>모델 기반(Model-based) 협업 필터링
    <ul>
      <li>데이터(rating matrix)에 내재되어 있는 패턴이나 속성을 학습한 모델을 만들고, 이것을 바탕으로 추천 결과를 생성하는 방식.</li>
      <li><strong>대표 알고리즘</strong>: Slope-One EF / Matrix Facotrization</li>
      <li><strong>장점:</strong> sparsity, scalability 문제에 상대적으로 더 잘 대처하는 것이 가능하고 예측 성능이 향상됨.</li>
      <li><strong>한계:</strong> 1) 모델 구축 비용이 큼 2) 예측 성능과 scalability 사이의 trade-off 3) 차원 감소로 인한 정보손실(SVD 실행 시 발생)</li>
    </ul>
  </li>
  <li>하이브리드(Hybrid) 방식 협업 필터링
    <ul>
      <li>메모리 기반 방식과 모델 기반 방식을 결합하여 사용하는 방식</li>
      <li><strong>대표 알고리즘</strong>: 메모리 기반과 모델 기반의 조합</li>
      <li><strong>장점</strong>: 각 방식의 단점을 보완하고 장점만을 취합할 수 있음</li>
      <li><strong>한계:</strong> 구현이 복잡해지고 비용이 증가함.</li>
    </ul>
  </li>
</ul>

<p><strong><small>[참고 자료]: https://www.samsungsemiconstory.com/2265, </small></strong></p>


	  ]]></description>
	</item>

	<item>
	  <title>[머신러닝]나이브 베이즈 분류기(Naive Bayes Classifier)</title>
	  <link>//naivebayes</link>
	  <author></author>
	  <pubDate>2020-07-24T10:18:00+00:00</pubDate>
	  <guid>//naivebayes</guid>
	  <description><![CDATA[
	     <p>강남의 어느 검색 솔루션 기업에서 인턴한지 어연 4주차가 지나간다. 중간 지점을 지나가면서 한 것을 정리할 겸 나이브베이즈 문서 분류기 구현과 이론에 대해서 정리해 보려고 한다. <small>최대한 쉽게!!</small></p>

<p>나이브 베이즈 분류기는 베이즈 정리(Bayes’ theorem)을 사용한 분류 알고리즘이다. 이것은 전통적으로 텍스트 분류를 하는 분류기로 인공지능의 기능을 기학적으로 올려준 인공 신경망 알고리즘은 아니지만 머신 러닝의 중요한 알고리즘 중 하나로 꽤 좋은 성능을 보인다. 나이브 베이즈 분류기에서 사용하는 베이즈 정리는 무엇일까?</p>

<h3 id="베이즈의-정리bayes-theorem를-사용한-분류-기법">베이즈의 정리(Bayes’ theorem)를 사용한 분류 기법</h3>

<p>베이즈 정리는 조건부 확률을 계산하는 방법 중 하나이다. 다음과 같이 표현할 수 있다.</p>

<ul>
  <li><strong><em>P(A)</em></strong>: 사전확률(Prior). 사건 B가 발생하기 전 A가 가지고 있던 확률</li>
  <li><strong><em>P(B)</em></strong>: 정규화 상수(normalizing constant). B가 일어날 확률</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>***P(B</td>
          <td>A)***: 가능도(likelihood). A가 발생한 경우 B가 일어날 확률</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>***P(A</td>
          <td>B)***: 사후확률(Posterior). B가 발생한 후 A가 일어날 확률</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<table>
  <tbody>
    <tr>
      <td>이 때 ***P(A</td>
      <td>B)***를 구하려면, 다음과 같은 수식을 사용한다.</td>
    </tr>
  </tbody>
</table>

<p><script type="math/tex">P(A|B) = \frac {P(B|A)P(A)} {P(B)}</script>
주로 나이브 베이즈 분류기법을 설명할 때 스팸 메일 분류기를 예를 들어서 설명한다.</p>

<h3 id="나이브-베이즈를-활용한-스팸-분류기">나이브 베이즈를 활용한 스팸 분류기</h3>

<p>어떤 문서 D에 대하여 해당 문서가 스팸(S)클래스에 속하는지 일반(!S)클래스에 속하는지 분류할 때 나이브 베이즈 분류 알고리즘을 사용한다고 하자. 그리고 이미 각기 다른 단어들에 대해서 해당 단어가 스팸일 확률과 일반일 확률에 대한 데이터가 이미 확보되어 있다고 가정한다. 한번 기호로 살펴보자. 우리가 가지고 있는 데이터는 다음 두개와 같다. 다음은 각각 “Sale이라는 단어는 60%의 확률로 스팸메일에서 발견되고, 30%의 확률로 일반메일에 발견된다.”라는 정보를 가지고 있는 것이다. 
<script type="math/tex">P('Sale'|S), P('Sale'|!S)</script>
 데이터를 수 만개의 단어들에 대한 위의 데이터를 활용해서 결국 풀고 싶은 문제는 $P(S|D)$와 $P(!S|D)$이다. 다음 두 확률을 구한 다음 확률이 더 큰 클래스에 해당 문서가 속한다고 결론을 내린다. $P(S|D)$는 문서 $D$가 주어졌다는 가정하에 해당 문서가 스팸일 조건부 확률을 나타낸다. 반대로 $P(!S|D)$는 문서 $D$가 주어졌다는 가정하에 해당 문서가 스팸이 아닐 조건부 확률을 나타낸다. 해당 문서를 어떤 클래스에 속하는지 분류하려면 먼저 문서에서 feature를 추출해야 한다. 추출된 feature들이 어떤 규칙에 의한 키워드 단어들이라고 할 때, 베이즈 정리는 특징벡터$x=(x1, x2, …, xn)$의 요소들이 모두 <strong>조건부 독립</strong>이라는 가정을 한다. 즉, 각 단어들이 서로 미치는 확률에 있어서 연관이 없다고 가정하는 것이다. <small>(이 부분에서 ‘Naive(순진한) ‘라는 이름이 붙는다. 실제로는 모두 독립적이지 않고 동등하지 않은데 이렇게 간주해버리는 순진함을 가지고 있다.)</small> 이때 해당 특징벡터 $x$에 대한 클래스 $S$에 속할 확률은 다음과 같다.
<script type="math/tex">P(S|x1,x2,...,xn)=\frac {P(x1,x2,...,xn)P(S)}{P(x1,x2,...,xn)}</script>
 앞에서 언급했듯이 각 feature의 요소들은 조건부 독립이기 때문에 다음과 같이 바꿔 쓸 수 있다. 
<script type="math/tex">P(S|x1,x2,...,xn)=\frac {P(x1|S)P(x2|S)...P(xn|S)P(S)}{P(x1)P(x2)...P(xn)}</script>
위와 같이 수식을 사용하면 문서를 특정 클래스들로 분류하기 위해서는 다음만 알면 된다. <strong>1) 문서로부터 특징벡터를 추출하는 방법 2)기존에 확보된 데이터로부터 $P(S|x)$와 $P(!S|x)$를 계산하는 방법 3)각 클래스의 비율인 사전확률 $P(S),P(!S)$.</strong> 해당 문제를 해결하기 위해 주어진 문서로 부터 판단에 사용할 특징feature를 추출해야 하는데 이때 어떤 확률분포를 사용하는지에 따라 특징벡터가 달라지게 된다.</p>

<h3 id="나이브-베이즈-분류기-3종류">나이브 베이즈 분류기 3종류</h3>

<p>나이브 베이즈 분류기에는 다음과 같이 3 종류가 있다. 세가지를 모두 다루지는 않고 인턴 기간동안 구현한 Bernoulli naive bayes classifier에 대해서 주로 다룰 것이다. 다만 3종류는 어떠한 것이 있고 각각의 특징과 다른점들에 대해서 간단히 설명하고 넘어가보자.</p>

<ol>
  <li>Gaussian naive bayes classifier: 설명변수가 연속형인 경우
    <ul>
      <li>연속적인 데이터에 적용 가능</li>
    </ul>
  </li>
  <li>Multinomial naive bayes classifier: 설명변수가 범주형인 경우
    <ul>
      <li>카운트 데이터(횟수)에 적용 가능</li>
    </ul>
  </li>
  <li>Bernoulli naive bayes classifier: 설명변수가 이분형인 경우
    <ul>
      <li>이진 데이터에 적용 가능.</li>
    </ul>
  </li>
</ol>

<p>Gaussian naive bayes는 주로 매우 고차원적인 데이터 세트를 다룰 때 사용된다. 나머지 두 베이즈 모델인 다항분포(Multinomial)과 베르누이(Bernoulli)는 보다 텍스트와 같은 데이터에 사용된다. 인턴하는 회사에서 요구한 업무는 문서에 대한 분류기이니 후자가 더 적합하다. 그 중, 내가 맡은 업무는 베르누이를 사용한 나이브 베이즈 문서 분류기이다.</p>

<h3 id="bernoulli-naive-bayes-분류기">Bernoulli Naive Bayes 분류기</h3>

<p>일부 코드를 제시하면서 구현 로직 설명을 하겠지만 인턴 회사의 코드이므로 모든 공개가 어렵다. 또한 여기서 참고할 점은 구현 언어가 회사 내에서 개발한 새로운 언어라는 것이다. 머신러닝을 사용한 인공지능 회사인 만큼 자체적으로 로직을 짜고 데이터를 처리하기에 더 적합한 언어를 포팅하여 사용하고 있다. 따라서 큰 로직만 참고하는 것을 추천한다.</p>

<p>먼저 텍스트 분류에 크게 사용되는 베르누이 확률 분포 모형과 다항분포 모형을 비교하며 간단히 어떤 차이가 있는지 살펴보자.</p>

<p>먼저 다항분포는 표본벡터 $x$가 있다고 가정했을 때, 이것을 $D$면을 가진 주사위를 $y$번 던진 결과라고 본다. 즉, $x=[1, 4, 0, 5]$가 있을 때, 다음 표본벡터는 4면체 주사위를 10번 던져서 1인 면이 1번, 2인 면이 4번, 4인 면이 5번 나온 결과이다. $K$개의 class가 있다면 $D$개 면을 가진 주사위 $K$개가 있다고 보고, 주사위를 던진 결과로부터 $1, … ,K$중 어떤 주사위를 던졌는지 찾아내는 것이라고 이해한다. <u>문서 내에 특정 단어가 몇번 등장하는지에 대한 횟수를 모형화 할 수 있다.</u></p>

<p>베르누이분포는 $x$의 원소가 0 또는 1 값만을 가질 수 있다. 위와 다르게 독립변수는 $D$개의 독립적인 확률변수를 가지고 있는, 동전으로 구성된 동전 세트로 표현할 수 있다. 각각의 값은 0 또는 1이다. $K$개의 클래스를 가지고 있다고 할 때, 전체 $D * K$의 조합의 동전이 존재하며 같은 class에 속하는 D개의 동전이 하나의 동전 세트를 구성하고 이런 동전 세트가 $K$개 있다고 볼 수 있다. 즉 베르누이를 사용한 나이브 베이즈 모형은 동전 세트를 N번 던진 결과로부터 1, …, $K$ 중 어느 동전 세트를 던졌는지 찾아내는 것이다. <u>문서 내에 특정한 단어가 포함되어 있는지의 여부로 확률을 판단할 때 주로 사용한다.</u></p>

<ul>
  <li>feature_count: 각 class k에 대해 d번째 동전이 앞면이 나온 횟수 $N_d,_k$</li>
  <li>feature_log_prob: 베르누이분포 모수의 로그값</li>
</ul>

<script type="math/tex; mode=display">log\mu_k = (log\mu_1,_k,...,log\mu_D,_k) = (log\frac{N_1,_k}{N_k},...,log\frac{N_D,_k}{N_k})</script>

<p>$N_k$는 class k에 대해서 동전을 던진 횟수이다.</p>

<hr />

<p>다음 파이썬 코드를 잠깐 훑으며 베르누이 확률분포를 사용해 나이브베이즈 분류 확률을 구하는 과적을 살펴보자.</p>

<pre><code class="language-pseudocode">x = np.array([
[0, 1, 1, 0],
[1, 1, 1, 1],
[1, 1, 1, 0],
[0, 1, 0, 0],
[0, 0, 0, 1],
[0, 1, 1, 0],
[0, 1, 1, 1],
[1, 0, 1, 0],
[1, 0, 1, 1],
[0, 1, 1, 0]])

y = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1]) //class 분류
</code></pre>

<p>클래스는 0과 1로 총 2개라고 본다. $x$는 확률변수를 가지고 있는 동전 세트로 볼 수 있고, $y$는 각 세트에 대한 클래스를 정의해 놓은 것이다. 처음 4개 세트는 class 0, 다음 6개 세트는 class 1이다.</p>

<p>각 클래스 $k$별, 독립변수 $d$별로 총 8개의 베르누이 확률변수의 모수를 구하면 다음과 같다. (각 클래스 별로 합치는 것)</p>

<pre><code class="language-pseudocode">array([[2, 4, 3, 1],
	   [2, 3, 5, 3]])
</code></pre>

<p>$[2, 4, 3, 1]$이 어떻게 나왔는지 간단하게 설명해보겠다. $x$의 첫번 째 4 세트가 class 0이므로 각각 첫번째 요소가 1인 횟수를 더하여서 2, 두번째 요소가 1인 횟수를 더하여서 4, … 이렇게 합친다.</p>

<p>이렇게 합쳐진 요소들에 대해서 각 클래스의 전체 개수로 나누어 주어야 한다. 위 예시의 경우 class 0의 전체 개수는 4이고 1의 전체 개수는 6이다. 결과는 다음과 같다.</p>

<pre><code class="language-pseudocode">array([[0.5,   1,   0.75,    0.25],
	   [0.333, 0.5, 0.83333, 0.5]])
</code></pre>

<p>여기서 이제 <strong>스무딩(Smoothing)</strong>을 해야한다. 표본 데이터의 수가 그렇지 않음에도 불구하고 0 또는 1이라는 극단적인 값이 나오게 된다. <small>(현실에서 그런 확률은 거의 없다)</small> 따라서 이런 현상을 방지하기 위해서 베르누이는 모수가 0.5인 가장 일반적인 경를 가정하여서 0이 나오는 경우와 1이 나오는 경우의 가장 표본 데이터를 추가하여 스무딩한다. 주로 smoothing은 가중치 $\alpha$의 값으로 스무딩을 조절한다. 이것을 <em>==라플라스 스무딩(Laplace smooting)==</em> 또는 <em>==애드원(Add-One) 스무딩==</em>이라고 한다.</p>

<script type="math/tex; mode=display">\mu_d,_k = \frac {N_d,_k + \alpha} {N_k + 2\alpha}</script>

<p>위에서 스무딩 가중치 $\alpha$를 1.0을 주었을 때 결과 값은 다음과 같다. 확인해보면 1과 같은 극단적인 값이 없어졌음을 볼 수 있다.</p>

<pre><code class="language-pseudocode">array([[0.5,   0.833333, 0.66667, 0.33333],
	   [0.375, 0.5,      0.75,    0.5]])
</code></pre>

<p>예측을 하기 위해 $[0, 0, 1, 1]$ 을 입력하면 $array([0.0953 , 0.9046])$ 값이 나온다. 즉 3, 4번 키워드가 포함되어 있다면 class 1 일 확률이 90%라는 의미이다.</p>

<h3 id="implementation---문서-분류기-구현">Implementation - 문서 분류기 구현</h3>

<p>원리를 이해했다면 구현은 생각보다 간단하다. 물론 파이썬의 sklearn등의 모듈을 사용하면 나이브 베이즈와 각 확률분포에 대한 기능이 모두 구현되어 있다. 따라서 가져가 쓰기면 하면 된다. 여기서는 문서분류기에 해당 알고리즘을 모듈을 사용하지 않고 어떻게 구현해야 하는지를 다룰 것이다. 앞서 말했든 사내에서 쓰는 언어를 사용한 것이 때문에 코드구현은 플로우만 참고하는 것을 추천한다.</p>

<h4 id="학습-learn">학습 Learn</h4>

<ul>
  <li>Input: 텍스트, 분류 클래스</li>
</ul>

<ol>
  <li>문서 키워드를 추출한다. 키워드 추출은 사용자마다 다른 기능이나 모듈을 가져와서 기준에 따라 추출할 수 있다.</li>
  <li>중복 제거를 위해 추출된 키워드를 Set에 입력시킨다.</li>
  <li>클래스 횟수가 저장되어 있는 자료구조에 해당 클래수 횟수를 1 증가시킨다.</li>
  <li>해당 클래스의 해당 단어의 여부를 기록하기 위해 해당 자료구조에 1을 더한다.</li>
  <li>전체 단어를 저장하는 자료구조에 단어를 추가한다.</li>
</ol>

<p>위에서 설명한 베르누이 확률분포를 계산하기 위한 $N_d,_k$와 $N_k$를 계산하는 과정으로 이해하면된다. 다음은 해당을 특정 언어로 코딩한 일부분이다. 여기서 m_n_cls와 m_n_cls_word등의 자료구조는 hash이고 m_words는 set이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">BernoulliModel</span><span class="o">::</span><span class="n">learn</span><span class="p">(</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="n">string</span> <span class="n">cls</span><span class="p">){</span>
    <span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tok</span><span class="p">;</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">extract_words</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">trim</span><span class="p">(),</span> <span class="n">m_lang</span><span class="p">,</span> <span class="n">m_charset</span><span class="p">;</span>
    <span class="n">m_n_cls</span><span class="p">[</span><span class="n">cls</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
                        
    <span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">word_set</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">word</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">word</span> <span class="n">in</span> <span class="n">tok</span> <span class="p">{</span>
        <span class="n">word_set</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>                    
    
    <span class="k">for</span> <span class="n">word</span> <span class="n">in</span> <span class="n">word_set</span> <span class="p">{</span>
        <span class="n">m_n_cls_word</span><span class="p">[</span><span class="n">cls</span><span class="o">+</span><span class="s">"_"</span><span class="o">+</span><span class="n">word</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">m_words</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="p">}</span>                    
<span class="p">}</span>
</code></pre></div></div>

<h4 id="예측-predict">예측 Predict</h4>

<ul>
  <li>Input: 예측할 테스트, Smoothing을 위한 $\alpha$</li>
</ul>

<ol>
  <li>입력 텍스트에 대해서 키워드를 추출함</li>
  <li>클래쓰 목록을 가져와서 각 클래스마다 다음을 반복함(해당 클래스의 Score를 구함)</li>
  <li>분모에 총 클래스 횟수와 smoothing값을 더함.</li>
  <li>추출된 각 키워드에 대해서 확률분포값과 smoothing 값을 더하여서 위의 분모로 나눈 log를 계산함(위에 베르누이 확률 계산 공식을 참고)</li>
  <li>각 클래스의 점수를 누적하여 예측함.</li>
</ol>

<pre><code class="language-pseudocode">BernoulliModel::predict(string fe, string lang, string charset, hash&lt;string,double&gt;&amp; score_hash, double alpha){
	list&lt;string&gt; tok;
	list&lt;string&gt; cls_list;
	double denom;
	double score;
	string cls;
	string t;
	
	tok = extract_word(fe.trim(), lang, charset);
	cls_list = m_n_cls.key();
	
	for cls in cls_list {
		socre = 0.0;
		denom = double(m_n_cls[cls]) + 2*alpha;
		for t in tok{
			score += log(m_n_cls_wor[cls+"_"+t]+alpha) / denom);
		}
		score_hash[cls] += score;
	}
}
</code></pre>

<p>다음을 예측해서 Score가 가장 높은 cls 소속임을 예측한다. 다항분포 모델이랑 비교하여 새로 구현한 베르누이 나이브 베이즈 문서 분류기의 성능을 테스트 해 보았을 때 81~82% 정도의 정확성을 보이는 것을 확인했다. 다항분포는 84~85%정도의 성능이었던 것을 고려해보면 확실히 정확한 횟수보다 여부만을 가지고 계산하는 베르누이 분류기의 성능이 다소 떨어지는 것을 확인할 수 있었다.</p>

<ul>
  <li>결과:</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/63405904/110242446-88655c00-7f99-11eb-9da7-5484473f3160.png" alt="Bernoulli" /></p>

<p><small><strong>[참고 자료]:</strong>  https://nbviewer.jupyter.org/github/metamath1/ml-simple-works/blob/master/naive/naive.ipynb, https://wikidocs.net/22892, https://heung-bae-lee.github.io/2020/04/14/machine_learning_07/</small></p>


	  ]]></description>
	</item>


</channel>
</rss>
