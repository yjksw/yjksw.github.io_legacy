<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>yjksw.github.io/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[이분탐색] 백준 1300 - k번째 수</title>
	  <link>//baek1300</link>
	  <author></author>
	  <pubDate>2020-10-11T10:18:00+00:00</pubDate>
	  <guid>//baek1300</guid>
	  <description><![CDATA[
	     <h3 id="문제">문제</h3>

<p><a href="https://www.acmicpc.net/problem/1300">문제 바로가기</a></p>

<h5 id="문제-분석-">문제 분석 &gt;</h5>

<p>크기가 NxN인 배열 A는 각각 A[i][j] = ixj 로 채워져 있다. 이 수를 NxN 크기의 일차원 배열 B에 오름차순 정렬하였을 때, B[k]의 값은 무엇인가?</p>

<p>배열 A, B의 index는 1부터 시작한다.</p>

<h5 id="입력-">입력 &gt;</h5>

<p>첫 줄에 배열의 크기 N ($0 \le N \le 10^5$) 과 둘째 줄에 k (min($10^9, N^2$)) 가 주어진다.</p>

<h5 id="출력-">출력 &gt;</h5>

<p>B[k] 값을 출력한다.</p>

<h3 id="예제">예제</h3>

<p>&lt;img src=”baek1300.png” width=70%/&gt;</p>

<h3 id="접근법">접근법</h3>

<ol>
  <li>배열 B에 들어가 있는 값의 범위는 1부터 N x N 이다.</li>
  <li>해당 범위를 이분탐색 하여 해당 숫자보다 작거나 같은 숫자가 몇개인지 구하여 배열 B에서의 index를 파악한다.</li>
  <li>해당 숫자보다 작거나 같은 숫자를 구하려면 숫자를 행마다 나눈 몫을 더하면 된다.
    <ul>
      <li>다만 주의할 것은 몫이 N 보다 크면 N으로 측정해야 한다.</li>
      <li>예를 들어, N이 5이고, 탐색 중인 숫자가 8일때, 8%1 = 8 이지만 N이 5 이므로 총 5개까지만 포함해야 한다.</li>
    </ul>
  </li>
  <li>index값이 k보다 크거나 같으면 이분할 한 왼쪽을 재탐색하고, index 값이 작으면 오른쪽을 재탐색한다.</li>
  <li>k에 대한 Lower bound를 이분탐색으로 찾아서 해당 값을 return 한다.</li>
</ol>

<h3 id="코드">코드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
    
    <span class="kt">long</span> <span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
    
    <span class="kt">long</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="k">while</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
     	<span class="kt">long</span> <span class="n">index</span> <span class="o">=</span> <span class="n">findIndex</span><span class="o">(</span><span class="n">mid</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
      
      <span class="k">if</span><span class="o">(</span><span class="n">index</span><span class="o">&gt;=</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
    <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Long</span> <span class="nf">findIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="n">in</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">cnt</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">num</span><span class="o">/</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="유의할-점">유의할 점</h3>

<ol>
  <li>
    <p>여기서 이분탐색 범위 right에는 k값이 들어가도 되고, n*n 값이 들어가도 된다.</p>

    <ul>
      <li>
        <p>배열의 특성상, 앞에 중복되는 숫자가 많기 때문에 index k에 들어가는 값은 무조건 k보다 작은 수이기 때문이다.</p>
      </li>
      <li>
        <p>하지만 논리상으로 1부터 n*n까지를 탐색하는 것이기 때문에 어느 것이 들어가도 상관 없다 (k가 더 빠르긴 하다.)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>1에서 right 값에 k값은 넣는다면 n이 int라도 상관이 없지만, n*n을 넣을 것이라면 right 변수가 Long 타입 이더라도 nxn을 하면서 int형으로 overflow가 발생하고 long 에 담기기 때문에 n이 long 타입으로 선언이 되어야 한다.</p>
  </li>
</ol>

<h3 id="느낀-점">느낀 점</h3>

<ul>
  <li>이분 탐색 문제들을 집중공략 하면서 이분탐색에 대해서 어느 정도 안다고 생각했다. 그리고 이 문제를 푸는데 오후 내내 이분탐색을 응용한 방법이 기억이 나질 않는 것이다…ㅠㅠ 아직 한쪽으로 밖에 생각하지 못하는 것 같다. 한 알고리즘을 익힐 때 여러 응용방법에 대해서 생각하는 힘을 기르기!</li>
  <li>이분 탐색은 할 때마다, 반복문을 빠져나왔을 때 내가 최종적으로 원하는 답이 right 인지 left 인지 헷갈려서 손으로 하나씩 해봐야지 알 수 있었다. 언제는 right 이고 언제는 left인데 분명 일관된 상황이 있을텐데.. 조금 더 분석을 해봐야겠다!!</li>
  <li>변수마다 overflow가 발생하는 시점에 대해서 아직도 모르다니.. java에 아직 미숙하다. int끼리 연산할 때 연산하는 중간에 int 범위를 넘으면 overflow가 발생한다니.. 앞으로 기억하자.</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>[브루트포스] 백준 1018 - 체스판 다시 칠하기</title>
	  <link>//baek1018</link>
	  <author></author>
	  <pubDate>2020-10-03T10:18:00+00:00</pubDate>
	  <guid>//baek1018</guid>
	  <description><![CDATA[
	     <h2 id="문제">문제</h2>

<p><a href="https://www.acmicpc.net/problem/1018">문제 바로가기</a></p>

<h4 id="문제-분석-">문제 분석 &gt;</h4>

<p>각 칸에 검은색과 흰색이 섞여서 칠해있는 M x N 보드가 있을 때 해당 보드에서 검은색과 흰색이 칠해져 있는 8 x 8 체스판을 만들 때 최소로 다시 칠해야 하는 칸의 갯수는 얼마인지 구하라.</p>

<h4 id="입력-">입력 &gt;</h4>

<p>첫 줄에 N$(8\le N \le 50)$ 과 M$(8 \le M\le 50)$이 주어진다. 두번째 줄부터 보드의 각 행에 대한 정보가 주어진다. 검은색은 B, 흰색은 W로 나타난다.</p>

<h4 id="출력-">출력 &gt;</h4>

<p>다시 칠해야 하는 칸의 최솟값을 출력한다.</p>

<h2 id="예제">예제</h2>

<p><img src="https://user-images.githubusercontent.com/63405904/112264605-77645c80-8cb4-11eb-8409-c2dac955da02.png" alt="image" /></p>

<h2 id="접근법">접근법</h2>

<ol>
  <li>8 x 8 체스판을 만들 수 있는 모든 경우의 수를 고려함.</li>
  <li>해당 8 x 8 체스판을 한칸씩 확인하면서 제대로 칠해져 있지 않은 칸 갯수를 구함.</li>
  <li>Min 변수와 비교하여 더 작은 숫자로 업데이트함.</li>
</ol>

<h2 id="코드">코드</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span> 
    <span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">m</span><span class="o">];</span>
    
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
      <span class="n">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
        <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">startX</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">startX</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">7</span><span class="o">;</span><span class="n">startX</span><span class="o">++){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">startY</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">startY</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="mi">7</span><span class="o">;</span><span class="n">startY</span><span class="o">++){</span>
        <span class="kt">char</span> <span class="n">compare</span> <span class="o">=</span> <span class="sc">'B'</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">beginColor</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">beginColor</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">;</span><span class="n">beginColor</span><span class="o">){</span>
          <span class="k">if</span><span class="o">(</span><span class="n">beginColor</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span>
            <span class="n">compare</span> <span class="o">=</span> <span class="sc">'W'</span><span class="o">;</span>
          <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
          <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">startX</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">startX</span><span class="o">+</span><span class="mi">8</span><span class="o">;</span><span class="n">k</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="n">startY</span><span class="o">;</span><span class="n">l</span><span class="o">&lt;</span><span class="n">startY</span><span class="o">+</span><span class="mi">8</span><span class="o">;</span><span class="n">l</span><span class="o">++){</span>
              <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">l</span><span class="o">]!=</span><span class="n">compare</span><span class="o">)</span>
                <span class="n">count</span><span class="o">++;</span>
              <span class="k">if</span><span class="o">(</span><span class="n">compare</span> <span class="o">==</span> <span class="sc">'B'</span><span class="o">)</span>
                <span class="n">compare</span> <span class="o">=</span> <span class="sc">'W'</span><span class="o">;</span>
              <span class="k">else</span> 
                <span class="n">compare</span> <span class="o">=</span> <span class="sc">'B'</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">compare</span> <span class="o">==</span> <span class="sc">'B'</span><span class="o">)</span>
              <span class="n">compare</span> <span class="o">=</span> <span class="sc">'W'</span><span class="o">;</span>
            <span class="k">else</span>
              <span class="n">compare</span> <span class="o">=</span> <span class="sc">'B'</span><span class="o">;</span>
          <span class="o">}</span>
          <span class="n">min</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="n">sc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">min</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="유의할-점">유의할 점</h2>

<ul>
  <li>8 x 8 체스판의 경우의 수를 찾을 때 n-7과 m-7까지만 고려하면 된다! 그 이상은 8 x 8 체스판을 생성하지 못하기 때문.</li>
  <li>체스판이 칠해질 수 있는 2가지 경우, B로 시작할 때와 W로 시작할 때 모두를 고려해야 한다.</li>
</ul>

<h2 id="느낀-점">느낀 점</h2>

<ul>
  <li>Brute force 답게 모든 경우를 다 고려해야만 풀 수 있는 문제였다.</li>
  <li>코드가 깔끔하지 않아서 더 좋은 방법이 있나 찾아보고 리팩토링 해보았지만 여기서 더 효율적인 방법은 찾지 못했다.</li>
  <li>이렇게까지 무식하게까지 비교라니…!!</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>[알고리즘] 이분 탐색(Binary Search)응용 파라메트릭서치(Parametric Search)</title>
	  <link>//bin-search-parametric-Search</link>
	  <author></author>
	  <pubDate>2020-09-28T10:18:00+00:00</pubDate>
	  <guid>//bin-search-parametric-Search</guid>
	  <description><![CDATA[
	     <p>백준 이분탐색 알고리즘 <a href="https://www.acmicpc.net/problem/1654">문제</a>를 풀다가 <strong>Parametric Search</strong>라는 새로운 개념을 접하게 되었다. 처음 이 랜선 자르기 문제를 접했을 때, 어느 부분에서 이분탐색을 응용해야하는 건지 감이 잡히지 않았다. 아마도 sorting된 특정한 input에 특정한 값을 탐색하는 분야로만 이분탐색을 한정지어서 생각했기 때문에 그 틀에서 벗어난 응용을 생각하기 힘들었던 것 같다. 이런 것을 보면 아직 알고리즘 쪽으로 한참은 더 발전해야 한다고 생각한다.</p>

<h3 id="parametric-search파라메트릭-서치">Parametric Search(파라메트릭 서치)</h3>

<h5 id="이진탐색과의-차이점">이진탐색과의 차이점:</h5>

<ul>
  <li>
    <p>주어진 일련의 값들이 아니라, 주어진 범위 내에서 원하는 값이나 특정한 조건에 일치하는 값을 찾아내는 알고리즘.</p>

    <p>Ex. 이진 탐색 - 1~9에서 3이라는 값을 찾아내는 알고리즘</p>

    <p>​	   파라메트릭 서치 - 1~9 범위에서 어떠한 조건을 만족하는 3을 찾아가는 알고리즘.</p>
  </li>
</ul>

<h5 id="장점">장점:</h5>

<p>Parametric Search를 사용하면 최적화 문제를 결정 문제로 바꾸어 풀 수 있는 장점이 있다.</p>

<ul>
  <li>ex. 최대값, 최소값을 찾는 문제 -&gt; 특정 값이 어떤 조건을 만족하는지 확인하는 문제.</li>
</ul>

<h3 id="parametric-search를-응용한-랜선-자르기-풀이">Parametric Search를 응용한 [랜선 자르기] 풀이</h3>

<ul>
  <li>
    <p><strong>[문제 분석]</strong>: 오영식은 K개의 각기 다른 길이를 지닌 랜선을 가지고 있다. 이 랜선들을 가지고 N 개의 랜선을 만들고 싶을 때, N개 혹은 이상의 랜선을 맨들 수 있는 랜선의 최대 길이는 무엇인가?</p>
  </li>
  <li>
    <p><strong>[입력]</strong>: 랜선 갯수 k, 만들고 싶은 랜선 갯수 n</p>

    <p>​			k 번 동안 각 랜선의 길이</p>
  </li>
  <li>
    <p><strong>[문제풀이]</strong>:</p>

    <ol>
      <li>가장 긴 랜선의 길이를 범위로 &lt;1~랜선 길이&gt;를 범위로 parametric search를 한다.</li>
      <li>이분 탐색과 동일하게 탐색하지만, 같을 경우 해당 mid 값을 return 하는 것이 아니라, mid+1 부터 추가적으로 탐색을 진행해야 한다.
        <ul>
          <li>이것은 특정한 값을 찾는 것이 아니라, 최대 길이를 찾고 싶은 것이기 때문에 추가탐색을 해서 최대로 갈 수 있는 범위 까지 탐색해야하기 때문이다.</li>
        </ul>
      </li>
    </ol>

    <p>** 주의 사항: index가 합쳐지면서 long을 넘기 때문에 left, right, middle은 long을 사용해야 한다.</p>
  </li>
</ul>

<h4 id="코드">[코드]</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">{</span>
    <span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
    <span class="n">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
    
    <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="n">n</span><span class="o">;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
    
    <span class="kt">int</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
      <span class="n">input</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    
    <span class="kt">long</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">right</span> <span class="o">=</span> <span class="n">input</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="kt">long</span> <span class="n">middle</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="k">while</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">middle</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">input</span><span class="o">[</span><span class="n">i</span><span class="o">]/</span><span class="n">middle</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">&lt;</span><span class="n">n</span><span class="o">){</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


	  ]]></description>
	</item>

	<item>
	  <title>[동적계획법] 이항계수</title>
	  <link>//binomial-coefficient</link>
	  <author></author>
	  <pubDate>2020-09-24T10:18:00+00:00</pubDate>
	  <guid>//binomial-coefficient</guid>
	  <description><![CDATA[
	     <p>이런 말이 있다.</p>

<blockquote>
  <p>동적 계획법이라는 말은 전문가들이 전문가들처럼 보여줄 수 있도록 해주는 말이고 일반인들에게는 그냥 ‘기억해서 풀기’ 다.</p>
</blockquote>

<p>이항계수에 관련한 성질은 기억해두면 이후 코딩이나 알고리즘 문제를 풀 때 유용하기 때문에 기록해 준다. 이항계수를 풀 때 중요한 성질은 다음과 같다.</p>

<script type="math/tex; mode=display">{n \choose k} = {n \choose n-k}</script>

<script type="math/tex; mode=display">{n \choose k} = {n-1 \choose k} + {n-1 \choose k-1}</script>

<script type="math/tex; mode=display">\sum_{k=1}^n {n \choose k} = 2^n</script>

<p>위의 공식은 이항계수의 정의식을 참고해서 유도하는 방법으로 이항 계수의 정의식을 알고 있어야 한다.</p>

<script type="math/tex; mode=display">{n \choose k} = _{n}\mathrm{C}_{k} = \frac{n!}{(n-k)!k!}</script>

<h3 id="동적-계획법을-활용한-이항계수-풀이">동적 계획법을 활용한 이항계수 풀이</h3>

<p>이항계수에 관련한 알고리즘 문제를 풀기 위해서 이항계수의 2번째 성질을 이용하기로 한다. 그 이유는 2번째 성질이 동적 계획법 활용에 알맞게 더 작은 부분으로 분할하여 정복 할 수 있는 성질을 잘 드러내고 있기 때문이다. 다음 방법을 사용해서 알고리즘을 풀어보자.</p>

<p>여기서 일반 재귀나 분할 정복보다 동적 계획법에 알맞게 진행하기 위해서 memoization을 사용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//DAC</span>
<span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
	<span class="kd">static</span> <span class="kt">long</span><span class="o">[][]</span> <span class="n">value</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
		<span class="n">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>

		<span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

		<span class="n">coef</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
		<span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">coef</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="o">){</span>
			<span class="n">value</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">b</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">value</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span>
      
			<span class="k">if</span><span class="o">(</span><span class="n">value</span><span class="o">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
				<span class="n">coef</span><span class="o">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
			<span class="k">if</span><span class="o">(</span><span class="n">value</span><span class="o">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> 
				<span class="n">coef</span><span class="o">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
			<span class="n">value</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">+</span> <span class="n">value</span><span class="o">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>단순히 이항계수의 정의를 이용한 유도식을 재귀를 통해서 구현한 것이다. 다음과 같이 구현하면 작은 숫자들에 대해서는 충분히 답을 낼 수 있지만 숫자가 커지게 되면 할당해야 하는 배열의 크기가 기하급수적으로 커지게되고, 그 결과 값 또한 long 타입으로도 담을 수 없기 때문에 매우 제한적이다. 따라서 <a href="https://www.acmicpc.net/problem/11401">백준 11401</a>에서는 이항계수를 소수인 1,000,000,007로 나눈 프로그램을 작성하도록 되어 있다. 그 연산에 대해서는 2가지 접근 방법이 있다.</p>

<p>우선, 왜 위에서 소개한 이항계수 정의식에 바로 % 1,000,000,007을 하지 않는지에 대한 이유를 짚고 넘어가야 한다. 이항계수 정의식은 분수꼴이기 때문에 소수 p로 % 연산을 했을 때 분자와 분모에 나뉘어서 적용되지 않는다.</p>

<script type="math/tex; mode=display">\frac{N!}{K!(N-K)!}\%p\qquad  \Longrightarrow \qquad \text{나뉘어서 적용 불가}</script>

<h3 id="접근-방법--1-확장-유클리드-알고리즘">접근 방법  1. 확장 유클리드 알고리즘</h3>

<p>확장 유클리드 알고리즘은 기본 원리로 유클리드 호제법으로 GCD를 구하는 것을 따라가며, 두 정수 A,B가 주어졌을 때, 베주 항등식인 $Ax+By=gcd(A,B)$ 에서 gcd(A,B)를 구하고 정수해 (x,y)를 구하는 알고리즘이다.</p>

<p>여기서 사용하고 싶은 확장 유클리드 알고리즘의 항을 써보면 다음과 같다.</p>

<script type="math/tex; mode=display">(AB^{-1}) \% p</script>

<p>위에서 말했던 이항계수 정의식을 보면 $A$와 $B$에 각각 무엇이 대입되는지 알 수 있다. 여기서 확장 유클리드 알고리즘을 사용하는데, 확장 유클리드 알고리즘은 두 수의 최대공약수와 베주 항등식의 $x$와 $y$까지 구할 수 있는 알고리즘이다.</p>

<script type="math/tex; mode=display">Bx + py =1 \qquad (i)</script>

<script type="math/tex; mode=display">Bx \equiv 1 \pmod{p} \qquad (ii)</script>

<p>위의 (i)에서 확장 유클리드 알고리즘으로 정수해 $(x, y)$를 구할 수 있는데 그럼 다음 식에 대입하면 원하는 식을 구할 수 있다.</p>

<script type="math/tex; mode=display">(AB^{-1}) \% p \\= (AB^{-1} \cdot 1) \%p\\=(AB^{-1} \cdot Bx)\%p\\=Ax\%p</script>

<p>결론은, <strong>베주 항등식에서 구한 $x$와 정의식에서 정의한 $A$를 곱한 것을 $p$로 modular 하면 원하는 식을 구할 수 있다.</strong></p>

<p>여기서 확장 유클리드 알고리즘을 이해하고 최종적으로 $x$를 구하는 것이 어렵게 느껴졌는데, 구현해보니 지나치게 길거나 복잡하지는 않았다. 재귀를 사용해서 구현하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">euc</span><span class="o">(</span><span class="kt">long</span> <span class="n">p</span><span class="o">,</span> <span class="kt">long</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">%</span><span class="n">B</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
    <span class="n">euc</span><span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">p</span><span class="o">%</span><span class="n">B</span><span class="o">);</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="o">(</span><span class="n">p</span><span class="o">/</span><span class="n">B</span><span class="o">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong><small>[참고 자료]: https://onsil-thegreenhouse.github.io/programming/problem/2018/04/02/problem_combination/</small></strong></p>

	  ]]></description>
	</item>

	<item>
	  <title>[알고리즘]분할정복 - 백준 2261 가장 가까운 두 점</title>
	  <link>//dac-closestPoint</link>
	  <author></author>
	  <pubDate>2020-09-17T10:18:00+00:00</pubDate>
	  <guid>//dac-closestPoint</guid>
	  <description><![CDATA[
	     <p>분할정복 알고리즘을 배울 때 나오는 유명한 문제 중 하나이다. 하지만 난이도가 굉장히 높기 때문에 쉽게 접근하기 어려웠는데, 분할 정복에 남은 마지막 문제를 그냥 안풀고 넘어가기엔 마음에 걸려서 마음먹고 공부해보기로 했다.</p>

<p>백준 사이트에서도 검색을 추천하여 알고리즘을 공부하기를 권하기 때문에 검색을 통해 <a href="https://octorbirth.tistory.com/274">좋은 글</a>을 발견했다. 그리고 해당 문제의 솔루션을 이해하는데만 집중했다.</p>

<p>분할정복 문제를 반복해서 풀어보니 분할정복은 DP 만큼이나 여러가지 형태의 문제가 있으니 최대한 많은 문제들을 풀어보는 것이 중요하다는 것을 알 수 있었다. 그리고 여러 문제를 풀어 본 결과 다음을 깨달을 수 있었다.</p>

<ul>
  <li>분할정복에서 분할을 하는 이유 중 하나는 <strong>굳이 필요 없는 연산/비교 등을 하지 않기 위해서</strong>이다.</li>
</ul>

<p>다르게 이야기하면 <strong>쓸데없는 것을 쳐내기 위해서</strong> 특정 기준에 따라서 계속 분할을 하는 것이다. <a href="https://www.acmicpc.net/problem/2261">백준 2261</a> 문제를 보면 어떤 의미인지 알 수 있다. 이 사실이 나로 하여금 더 구현을 잘하게 해주지는 못하지만 <em>개발자 마인드</em>를 갖추는데 어느 정도 일조했다고 생각한다. 알고리즘 문제들을 풀면 풀수록 쌓이는 <em>개발자 마인드</em> 룰을 통해서 새로운 문제를 바라보더라도 개발자스럽게 생각해야지 적합한 알고리즘을 찾을 수 있다.</p>

<p>이렇게 지나지게 많은 비교 연산을 해야할 때 필요 없는 것이 무엇인지부터 접근해야 한다.</p>

<h2 id="문제-해결">문제 해결</h2>

<p>가장 가까운 두 점 문제의 솔루션을 요약하면 다음과 같다.</p>

<ol>
  <li>x값 기준으로 정렬.</li>
  <li>중간을 기준으로 왼쪽과 오른쪽을 나눔.</li>
  <li>왼쪽 가장 가까운 거리 d1, 오른쪽 가장 가까운 거리 d2 찾아냄.</li>
  <li>d1과 d2 중 더 최소값을 d 에다가 저장함.</li>
  <li>중간으로 가로지르는 점들 중 중앙과 d 이상 차이나는 점들을 제외함.</li>
  <li>해당 점들을 y 기준으로 정렬해서 위의 점과 높이가 d 이상 차이나는 점들을 제외하여 비교하여 d3을 구함.</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/63405904/111621456-5c649900-882b-11eb-9fc0-3f1dbdaca71e.png" alt="image" /></p>

<p>위의 그림을 보면 보다 직관적으로 이해할 수 있다. 위 과정을 반복하면서 최소값을 지속적으로 업데이트하면 최종적으로 최소값을 찾을 수 있다.</p>

<p>이렇게 x 값을 기준으로 정렬해서 제외한 후에, 아래 사진과 같이 y 값을 기준으로 또 정렬하여 제외시키면 된다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/111621504-69818800-882b-11eb-9fb4-7be3a658c7b8.png" alt="image" /></p>

<h2 id="솔루션-구현">솔루션 구현</h2>

<p>다음 솔루션을 구현하기 위해서 이해하거나 응용하면 좋을 개념들은 다음과 같다.</p>

<ol>
  <li>JAVA comparator</li>
  <li>재귀</li>
  <li>객체 생성</li>
</ol>

<p>“완전히 모르는 건 아닌데?” 라고 생각하기 쉽지만 제대로 생각해보면 나는 잘 활용하지 않았던 개념들이 있었다. 예를 들어, comparator를 생성하여 정렬하기 보다 조금 돌아가지만 이전에 하던 방식으로 일일이 정렬하는 방법을 주로 사용하고, 객체를 생성하여 코드가 직관적이게 되기 보다 배열에 나만 아는 규칙으로 끼워 넣는 경우가 많았던 것 같다. 한번 이 모든 개념들을 제대로 응용해서 좋은 코드를 짜보자.</p>

<p>아래의 대부분의 코드는 <a href="https://octorbirth.tistory.com/274">사이트</a>에서 참고하고 내가 조금의 업그레이드를 시킨 정도이다.</p>

<h4 id="java-comparator">JAVA Comparator</h4>

<p>JAVA Comparator는 배열이나 객체 등을 sorting 하기 위해서 매우 유용한 인터페이스이다. 숫자가 아닌 무언가, 또는 조금 다른 기준을 통해서 정렬을 하기 원할 때, 이 comparator를 정의하여 사용하면 매우 유용하다.</p>

<p>기본적인 사용방법은 다음과 같다.</p>

<ol>
  <li>Comparator를 implement 한 class 정의</li>
  <li><code class="highlighter-rouge">Arrays.sort</code>나, <code class="highlighter-rouge">Collections.sort</code>에서 내부 정렬 기준을 구현 하면됨.</li>
</ol>

<p>비슷한 기능을 하는 인터페이스로는 Comparable이 있다. 이것은 어떠한 클래스에서 implement 하여 내부에 있는 compareTo 함수를 통해 클래스 기본 정렬 기준을 설정하는 것이다.</p>

<table>
  <thead>
    <tr>
      <th>Comparable</th>
      <th>클래스의 기본 정렬 기준을 설정하는 인터페이스</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Comparator</td>
      <td>기본 정렬 기준과는 다르게 정렬하고 싶을 때 이용하는 클래스</td>
    </tr>
  </tbody>
</table>

<p>이번에 <strong>가장 가까운 두 점</strong> 문제에서는 Comparator를 사용하여 sort 메소드를 통해서 사용할 예정이다. 우선 점들을 x좌표 기준으로 정렬하고, 이후에 y 기준으로 정렬하는 2가지 기준으로 정렬하는 클래스를 생성한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">xComparator</span> <span class="kd">implements</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Point</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Point</span> <span class="n">p2</span><span class="o">){</span>
    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">p2</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">yComparator</span> <span class="kd">implements</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Point</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Point</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">p2</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="재귀-recursion">재귀 Recursion</h4>

<p>거의 모든 알고리즘 문제의 일부분이 되는 재귀이지만 이번 문제에서 재귀를 활용하면서 재귀에 대해서 한층 더 이해할 수 있었다. 재귀에도 tail-recursion과 head-recursion이 나누어져 있고, 코드가 복잡해 질수록 더더욱 어느 타이밍에 재귀를 호출하는지가 매우 중요하다.</p>

<p>이번 풀이에서는 앞서 소개한 문제해결 방식을 재귀적으로 반복하여 매번 왼쪽, 오른쪽, 중간 가로지르는 부분으로 분할해 최소 거리를 찾도록 하였다. 이렇게 head-recursion으로 호출한 후에 return 된 최소 거리를 저장하고 이후에 처리해야 할 코드를 수행한다.</p>

<h4 id="객체-생성">객체 생성</h4>

<p>매번 이런 두 점과 같은 문제가 나올 때, 2차원 배열을 생성해서 수행했었다. 물론 그래도 아무 문제가 없고 이런 경우가 메모리나 속도 측면에서 더욱 효율적인 경우가 많다. 하지만 객체를 생성해서 데이터를 저장해야만 할 때가 있는데, 객체 생성을 해서 저장하는게 익숙하지 못해서 하지 못하는 경우가 많기 때문에 이번 문제에서 점의 좌표를 클래스 객체에 한번 담에 보았다. 생각보다 매우 간단하지만 첫 걸음이 어려워서 자주 사용하지 못했다고 생각한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="전체-코드">전체 코드</h4>

<p>다음과 같은 구성을 가지고 있다.</p>

<ol>
  <li>점들 사이의 최소값을 분할정복으로 찾는 minDistance()</li>
  <li>특정 기준 이하의 점들 사이의 최소값을 brute-force로 찾는 searchMin()</li>
  <li>점들 사이의 거리를 계산하는 distance()</li>
  <li>xComparator와 yComparator</li>
  <li>Point 클래스 객체</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="n">Point</span><span class="o">[]</span> <span class="n">value</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
    <span class="n">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
    <span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
      <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
      <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
      <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
      <span class="n">value</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="k">new</span> <span class="n">xComparator</span><span class="o">());</span>
    
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">minDistance</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
    <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="o">(</span><span class="kt">int</span> <span class="n">begin</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">end</span><span class="o">-</span><span class="n">begin</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">&lt;=</span><span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nf">searchMin</span><span class="o">(</span><span class="n">begin</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">begin</span><span class="o">+</span><span class="n">end</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">minDistance</span><span class="o">(</span><span class="n">begin</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">minDistance</span><span class="o">(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
    
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">d1</span><span class="o">,</span> <span class="n">d2</span><span class="o">);</span>
    
    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">mid_list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">begin</span><span class="o">;</span><span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">xDist</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">mid</span><span class="o">].</span><span class="na">x</span> <span class="o">-</span> <span class="n">value</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">x</span><span class="o">;</span>
      <span class="k">if</span><span class="o">((</span><span class="n">xDist</span><span class="o">*</span><span class="n">xDist</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mid_list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">value</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
      <span class="o">}</span> <span class="k">else</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">end</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">xDist</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">mid</span><span class="o">].</span><span class="na">x</span> <span class="o">-</span> <span class="n">value</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">x</span><span class="o">;</span>
      <span class="k">if</span><span class="o">((</span><span class="n">xDist</span><span class="o">*</span><span class="n">xDist</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mid_list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">value</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
      <span class="o">}</span> <span class="k">else</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">mid_list</span><span class="o">,</span> <span class="k">new</span> <span class="n">yComparator</span><span class="o">());</span>
    <span class="kt">int</span> <span class="n">mlist_size</span> <span class="o">=</span> <span class="n">mid_list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mlist_size</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">mlist_size</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
        <span class="kt">int</span> <span class="n">yDist</span> <span class="o">=</span> <span class="n">mid_list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">y</span> <span class="o">-</span> <span class="n">mid_list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">).</span><span class="na">y</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">yDist</span><span class="o">*</span><span class="n">yDist</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
          <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">distance</span><span class="o">(</span><span class="n">mid_list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">mid_list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
          <span class="k">if</span><span class="o">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dist</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span>
          <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">distance</span><span class="o">(</span><span class="n">Point</span> <span class="n">a</span><span class="o">,</span> <span class="n">Point</span> <span class="n">b</span><span class="o">){</span>
    <span class="k">return</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">x</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="na">x</span><span class="o">)*(</span><span class="n">a</span><span class="o">.</span><span class="na">x</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">y</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="na">y</span><span class="o">)*(</span><span class="n">a</span><span class="o">.</span><span class="na">y</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="na">y</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
  
<span class="kd">class</span> <span class="nc">xComparator</span> <span class="kd">implements</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Point</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Point</span> <span class="n">p2</span><span class="o">){</span>
    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">p2</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">yComparator</span> <span class="kd">implements</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Point</span> <span class="n">p1</span><span class="o">,</span> <span class="n">Point</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">p2</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


	  ]]></description>
	</item>

	<item>
	  <title>순열과 조합</title>
	  <link>//permutation-n-combination</link>
	  <author></author>
	  <pubDate>2020-09-12T10:18:00+00:00</pubDate>
	  <guid>//permutation-n-combination</guid>
	  <description><![CDATA[
	     <p>Back-tracking 알고리즘을 공부할 때 제일 먼저 구현하는 것이 순열과 조합이다.</p>

<p>Back-tracking 알고리즘에 대해서 입문하고 감을 잡기 위해서 시작하기 좋은 코드이다. 따라서 순열과 조합을 구하는 코드를 보고 외워서 머릿속에 저장해두는 것을 추천한다.</p>

<blockquote>
  <p>순열과 조합의 차이점:</p>

  <ul>
    <li>순열: 순열은 순서가 있는 조합이다.(A Permutation is an ordered Combination)</li>
    <li>조합: 조합은 순서를 생각하지 않고 선택만 한다.</li>
  </ul>
</blockquote>

<h5 id="순열-코드">순열 코드</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Back-tracking 알고리즘</span>
<span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Iterator</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="n">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
    
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
    <span class="n">sc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="n">DFS</span><span class="o">(</span><span class="n">n</span><span class="o">,</span><span class="n">m</span><span class="o">);</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">DFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">cnt</span><span class="o">==</span><span class="n">count</span><span class="o">){</span>
      <span class="n">print</span><span class="o">();</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">num</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
        <span class="k">continue</span><span class="o">;</span>
      <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
      <span class="n">cnt</span><span class="o">++;</span>
      <span class="n">DFS</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
      <span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
      <span class="n">cnt</span><span class="o">--;</span>
    <span class="o">}</span>
  <span class="o">}</span>
 
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(){</span>
    <span class="n">Iterator</span> <span class="n">value</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%d "</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="na">next</span><span class="o">());</span> 
    <span class="o">}</span>   
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h5 id="조합-코드">조합 코드</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Back-tracking 알고리즘</span>
<span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Iterator</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
  <span class="kd">static</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
  <span class="kd">static</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="n">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
    <span class="n">sc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    
    <span class="n">DFS</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">DFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">count</span><span class="o">){</span>
      <span class="n">print</span><span class="o">();</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">idx</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">num</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
      <span class="k">if</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">i</span><span class="o">)!=-</span><span class="mi">1</span><span class="o">)</span>
        <span class="k">continue</span><span class="o">;</span>
      <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
      <span class="n">cnt</span><span class="o">++;</span>
      <span class="n">DFS</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">num</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
      <span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
      <span class="n">cnt</span><span class="o">--;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(){</span>
    <span class="n">Iterator</span> <span class="n">value</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%d "</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


	  ]]></description>
	</item>

	<item>
	  <title>재귀 vs. 반복</title>
	  <link>//recursion</link>
	  <author></author>
	  <pubDate>2020-09-11T10:18:00+00:00</pubDate>
	  <guid>//recursion</guid>
	  <description><![CDATA[
	     <p><strong>Binary Search</strong> 이분탐색을 구현하면서, 계속 런타임 에러가 났다. 처음에 재귀로 구현을 시작했는데, 재귀에 너무 큰 값이 들어오면서 stack overflow 에러가 났나 싶어서 다시 while 문으로 구현했다. 하지만 while 문으로 구현한 이후에도 계속 런타임 에러가 떠서 확인해보니, n과 m을 헷갈려서 잘못 적었던 것이었다.</p>

<p>이왕 while 문으로 구현해서 맞은 거, 재귀와 비교해 보자 해서 재귀를 돌려 보았더니, 재귀가 훨씬 빠르고 메모리 효율도 좋은 것이었다. 일반적으로 생각했을 때, 재귀는 매번 메모리를 할당하면서 새로운 함수를 call 해주어야 하고, 또 그만큼의 시간과 공간이 더 필요해서 반복문에 비해 성능이 다소 떨어진다고 알고 있었지만, 훨씬 빠르고 메모리 효율도 좋아서 그 이유에 대해서 찾아보게 되었다. 정답은 <strong>Tail-recursion.</strong></p>

<h2 id="tail-recursion">Tail-Recursion</h2>

<h3 id="tail-recursion이란">Tail-Recursion이란?</h3>

<p>Tail-Recursion이란 recursion 함수에서 가장 나중에 실행되는 명령어를 뜻한다. 마지막 시행 명령이 재귀 호출이라면, 해당 함수는 tail-recursion의 형태를 가지고 있다고 할 수 있다.</p>

<h3 id="tail-recursion의-효능">Tail-Recursion의 효능</h3>

<p>Tail-recursion은 주로 non tail recursion에 비교해서 성능이 더 좋은 것으로 나타난다. 마지막 recursion을 call 하고, 해당 호출에 연산이 포함되어 있지 않는다면 컴파일러에 의해서 해당 tail-recursion 함수는 optimize 된다. 이 이유는, tail-recursion 함수의 경우, 함수의 가장 마지막으로 실행하는 것이 recursive call이기 때문에 현재 머물고 있는 함수에 더 이상 진행할 instruction이 없고 따라서 현재 함수를 stack에 저장하지 않아도 된다. 때문에 non tail recursion 보다 더 빠르고, stack 메모리를 사용하지 않는 장점을 지닌다.</p>

<p>주의할 것은 다음과 같이 마지막에 recursive 함수 호출은 한다고 하더라도, 연산이 끼어 있다면, optimize 될 수 없다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">fac</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">){</span>
	<span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
	
	<span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">fac</span><span class="o">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="결과-비교">결과 비교</h3>

<p>백준 이분 탐색을 풀었을 때 결과 화면이다.</p>

<p>첫번째 실행이 tail recursion을 사용하여 구현했을 때이고, 두번째가 while 반복문을 사용하여서 구현한 것인데 tail recursion이 재귀를 사용했음에도 불구하고 그 시간이 현저히 빠르고 메모리 효율 또한 좋은 것을 확인할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/111058336-470d0900-84d1-11eb-9272-ebb0632be6b4.png" alt="image" /></p>


	  ]]></description>
	</item>

	<item>
	  <title>[알고리즘] 세그먼트 트리를 활용한 히스토그램 문제 풀이_2</title>
	  <link>//segment-tree2</link>
	  <author></author>
	  <pubDate>2020-09-10T10:18:00+00:00</pubDate>
	  <guid>//segment-tree2</guid>
	  <description><![CDATA[
	     <p>앞서 <a href="https://www.acmicpc.net/problem/6549">히스토그램 문제</a>에 대한 접근 방법을 간단하게 설명하고 세그먼트 트리를 히스토그램에 맞추어서 설명했다. 이번 글에서는 구체적으로 어떻게 세그먼트 트리를 구현하여 히스토그램 문제를 푸는데까지 이어지는지 다루어 보도록 하겠다.</p>

<p>이 문제는 레벨이 높은 문제이긴 하지만 아이디어 자체가 굉장히 어렵거나 하진 않다. 다만 시간 복잡도 측면에서 효율적으로 접근하기 위해 세그먼트 트리를 활용하는게 좀 낯설어서 어려웠던 것 같다.</p>

<h6 id="segment-tree-구현">Segment Tree 구현</h6>

<p>Segment Tree를 구현할 때 배열을 사용해서 구현하도록 할텐데 segment tree는 다음과 같은 성질을 가지고 있다.</p>

<ul>
  <li>세그먼트 트리는 거의 Full Binary Tree(비슷한 형태를 지님)의 모습을 하고 있다.</li>
  <li>왼쪽 자식: 부모노트 * 2</li>
  <li>오른쪽 자식: 부모노드 * 2 + 1</li>
  <li>높이: lgN</li>
</ul>

<p>배열을 통해서 tree를 구현하려면 사전에 tree의 노드 갯수를 파악해서 배열의 크기를 지정해야한다. 위의 성질들을 이용하면 해당 tree의 크기를 계산할 수 있다. 예를 들어 기존 배열의 개수가 <strong>2의 제곱인 경우</strong>에는 높기가 lgN 이므로 필요한 노드의 갯수는 <code class="highlighter-rouge">2*N-1</code> 이다. <strong>2의 제곱이 아닌 경우</strong>에는 N보다 큰지만 가장 가까운 2의 제곱을 찾으면 된다. 따라서 그 경우 노드의 갯수는 <code class="highlighter-rouge">2*2^(lgN+2)-1</code>이 된다.</p>

<p>이렇게 크기를 지정해서 배열을 생성한 이후에 재귀 함수를 사용해서 이전 포스트에서 이야기 했던 부분을 구현하면 된다. 재귀를 잘 이해했다면 segment tree 생성은 크게 어렵지 않다.</p>

<p><strong>코드:</strong></p>

<p>먼저 segment tree를 저장할 배열 공간을 할당한다.  다음은 구현할 때 유용한 몇가지 JAVA 함수를 소개해준다.</p>

<ul>
  <li>Ceil: 올림 숫자</li>
  <li>Math.log10(n)/Math.log10(2) = log2n</li>
</ul>

<p>Segment Tree의 index는 1부터 시작해야 한다. 그래야지 <code class="highlighter-rouge">2*i, 2*i+1</code>로 왼쪽 자식노드와 오른쪽 자식노드를 구별할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
  <span class="o">...</span>
  <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">ceil</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">log10</span><span class="o">(</span><span class="n">n</span><span class="o">)/</span><span class="n">Math</span><span class="o">.</span><span class="na">log10</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">height</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
  
  <span class="kt">int</span><span class="o">[]</span> <span class="n">binTree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
  <span class="n">init</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>다음은 segment tree에 값을 할당하는 부분이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
  <span class="k">if</span><span class="o">(</span><span class="n">start</span><span class="o">==</span><span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="n">init</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="o">(</span><span class="n">start</span><span class="o">+</span><span class="n">end</span><span class="o">)/</span><span class="mi">2</span><span class="o">,</span> <span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">);</span>
  <span class="n">init</span><span class="o">((</span><span class="n">start</span><span class="o">+</span><span class="n">end</span><span class="o">)/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
  <span class="k">if</span><span class="o">(</span><span class="n">value</span><span class="o">[</span><span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">]]&lt;=</span><span class="n">value</span><span class="o">[</span><span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">]])</span>
    <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">];</span>
  <span class="k">else</span>
    <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
  <span class="k">return</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h6 id="segment-tree-탐색">Segment Tree 탐색</h6>

<p>Segment Tree를 생성했으면 이제 각 구간을 순회하며 해당 구간의 최소값을 구해야 한다. 일반적인 세그먼트 트리의 예시에서 구간합을 구할 경우 각 segment tree에 있는 값의 합을 구하면 되지만, 히스토그램 문제에서는 최소값을 찾아야 하니, 한번 더 참조해야 하는 부분이 있다.</p>

<p>이 부분은 세그먼트 트리에 대해서 설명해놓은 <a href="https://www.acmicpc.net/blog/view/9">백준 블로그</a>를 참조하면서 이해 했는데 매우 잘 설명이 되어 있다. 세그먼트의 해당 노드가 담당하고 있는 구간을 [start, end]로, 합을 구하는 목적 구간을 [left, right]로 놓았을 때 다음 4가지 경우가 있다.</p>

<ol>
  <li>합을 구해야하는 [left, right]와 현재 노드가 담당하고 있는 [start, end]가 겹치지 않는 경우</li>
  <li>합을 구해야하는 [left, right]가 현재 노드가 담당하고 있는 [start, end]를 완전히 포함하는 경우</li>
  <li>현재 노드가 담당하고 있는 [start, end]가 [left, right]를 완전히 포함하는 경우</li>
  <li>[left, right]와 [start, end]가 겹쳐져 있는 경우 (1, 2, 3을 제외한 나머지)</li>
</ol>

<p>위의 4가지 경우에 대해서 다음과 같이 처리한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1번 경우: if(left &gt; end || right &lt; start) 
	- 겹치지 않으므로 탐색할 필요 없음
2번 경우: if(left &lt;= start &amp;&amp; end &lt;= right)
	- 해당 노드의 값을 리턴함
3,4번 경우:
	- 각각 왼쪽, 오른쪽 자식 노드에서 탐색함. 
</code></pre></div></div>

<p>히스토그램 문제에서는 최소값을 찾아야 하는 것이기 때문에 왼쪽과 오른쪽 자식 노드로 나누어서 들어갈 때, 배열을 한번 더 참조해서 구간에서 최종 최소값이 있는 위치를 찾아야 한다.</p>

<p><strong>코드:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">findMin</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">last</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
  <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">&gt;</span><span class="n">last</span> <span class="o">||</span> <span class="n">right</span><span class="o">&lt;</span><span class="n">start</span><span class="o">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="o">&gt;=</span><span class="n">last</span><span class="o">)</span>
    <span class="k">return</span> <span class="n">binTree</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">findMin</span><span class="o">(</span><span class="n">start</span><span class="o">,(</span><span class="n">start</span><span class="o">+</span><span class="n">last</span><span class="o">)/</span><span class="mi">2</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">temp2</span> <span class="o">=</span> <span class="n">findMin</span><span class="o">((</span><span class="n">start</span><span class="o">+</span><span class="n">last</span><span class="o">/</span><span class="mi">2</span><span class="o">)+</span><span class="mi">1</span><span class="o">,</span> <span class="n">last</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">index</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">temp1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">temp2</span><span class="o">;</span>
    <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">temp2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">temp1</span><span class="o">;</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">if</span><span class="o">(</span><span class="n">value</span><span class="o">[</span><span class="n">temp1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">value</span><span class="o">[</span><span class="n">temp2</span><span class="o">])</span>
        <span class="k">return</span> <span class="n">temp1</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">temp2</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h6 id="히스토그램-풀이">히스토그램 풀이</h6>

<p>위의 세그먼트 트리 생성과 탐색 방법을 사용해서 최소값을 찾는 부분을 구현했다면 이제 답을 구현하도록 해보자. 앞의 포스트에서 언급했던 방법은 아래이다.</p>

<blockquote>
  <p>먼저 <a href="https://www.acmicpc.net/problem/6549">문제</a>의 해결 방법을 요약하면 다음과 같다.</p>

  <blockquote>
    <ol>
      <li>히스토그램 중, 높이가 가장 낮은 min 값과 해당 너비값을 곱하여 넓이를 구함.</li>
      <li>해당 최소값을 기준으로 히스토램을 나누어서 1번을 반복함.</li>
      <li>더 이상 나눌 수 없을 때까지 반복하며 매번 넓이의 max 값을 업데이트 함.</li>
    </ol>
  </blockquote>
</blockquote>

<p>위의 방법이 분할정복인 이유는 반복적으로 나뉘어지는 구간에서의 직사각형을 계속 비교하면서 최대 크기를 찾기 때문이다. 세그먼트 트리에 저장된 최소값의 위치를 활용해서 해당 기준으로 나누고, 나눈 구간에서의 직사각형 넓이 구할 때 사용하도록 한다.</p>

<p><strong>코드:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lastIndex</span><span class="o">){</span>
  <span class="kt">long</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">startIndex</span> <span class="o">==</span> <span class="n">lastIndex</span><span class="o">){</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">startIndex</span><span class="o">];</span>
    <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
      <span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kt">int</span> <span class="n">minIndex</span> <span class="o">=</span> <span class="n">findMin</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">startIndex</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
  <span class="kt">long</span> <span class="n">min</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">minIndex</span><span class="o">];</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">minIndex</span> <span class="o">==</span> <span class="n">startIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">minIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">minIndex</span> <span class="o">&gt;=</span> <span class="n">lastIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">minIndex</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">minIndex</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">minIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong><small>[참고 자료]: https://www.acmicpc.net/blog/view/12, https://www.crocus.co.kr/648, https://www.acmicpc.net/blog/view/9 </small></strong></p>


	  ]]></description>
	</item>

	<item>
	  <title>[알고리즘] 세그먼트 트리를 활용한 히스토그램 문제 풀이_1</title>
	  <link>//segment-tree1</link>
	  <author></author>
	  <pubDate>2020-09-09T10:18:00+00:00</pubDate>
	  <guid>//segment-tree1</guid>
	  <description><![CDATA[
	     <p>히스토그램에서 가장 큰 직사각형의 크기를 찾는 알고리즘을 풀다가, 관련 문제의 풀이법을 간단히 찾아서 금방 해결할 줄 알았으니 구현에서 의도치 않은 오랜 시간이 걸렸다.</p>

<p>먼저 <a href="https://www.acmicpc.net/problem/6549">문제</a>의 해결 방법을 요약하면 다음과 같다.</p>

<blockquote>
  <ol>
    <li>히스토그램 중, 높이가 가장 낮은 min 값과 해당 너비값을 곱하여 넓이를 구함.</li>
    <li>해당 최소값을 기준으로 히스토램을 나누어서 1번을 반복함.</li>
    <li>더 이상 나눌 수 없을 때까지 반복하며 매번 넓이의 max 값을 업데이트 함.</li>
  </ol>
</blockquote>

<p>다음은 <a href="https://www.acmicpc.net/blog/view/12">백준 블로그</a>에 있는 문제 해설에서 가져온 그림이다. 위의 해결 방법을 이해하는데 도움이 된다.</p>

<p><img src="https://user-images.githubusercontent.com/63405904/109445062-10bb9c80-7a82-11eb-9887-9047f1485785.png" alt="histogram" /></p>

<p>처음에 단순히 이 풀이방법을 배열과 재귀를 사용해서 구현하는 방법으로 시도를 했었다. 사이트에 나와있는 테스트 케이스가 통과하길래 바로 채점을 했더니 결과는 <em>시간초과</em> 였다.. 개인적으로 알고리즘을 할 때 가장 어려운 부분이 답을 출력이 되지만 시간초과가 나올 때 인 것 같다. 문제설명 밑에 해당 문제를 세그먼트 트리를 사용한 분할정복으로 풀 수 있다고 하길래 세그먼트 트리에 대해서 공부하면서 정리한 내용과 처음에 접근했던 방식에 대해서 쓰려고 한다.</p>

<ol>
  <li>배열/재귀를 사용해서 풀었던 방법: <mark> 시간초과 </mark></li>
  <li>세그먼트 트리/분할정복을 사용해서 푼 방법: <mark>통과</mark></li>
</ol>

<h3 id="배열과-재귀를-사용한-첫번째-접근-방법">배열과 재귀를 사용한 첫번째 접근 방법</h3>

<p>배열과 재귀를 사용한 접근 방법은 간단하지만 번거롭다. 매번 나뉘어진 구간 사이에서의 <strong>최솟값</strong>을 찾는 과정을 반복해야 하기 때문이다.</p>

<h4 id="접근-방법-1-arraylist">접근 방법 1: ArrayList</h4>

<p>ArrayList를 사용해서 탐색 API를 사용해서 최솟값 구하기</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. ArrayList의 일부 구간을 subList를 사용하여 List에 저장한다.
2. Collections.min() 메소드를 사용하여 최솟값을 추출하여 넓이를 구한다. 
3. indexOf() 메소드를 사용하여 최솟값의 index를 구한다. 
4. 다음과 같은 재귀로 반복한다.
	* 맨 첫번째 요소가 최소값일 경우: 두번째 요소부터 마지막 요소까지 재귀
	* 맨 마지막 요소가 최소값일 경우: 첫본째 요소부터 마지막 이전 요소까지 재귀
	* 중간의 어느 값이 최소값일 경우: (시작 요소, 최소값 위치 -1)과 (최소값 위치 +1, 마지막 요소)로 나누어서 재귀
</code></pre></div></div>

<p>위의 방식은 조금만 큰 값이 들어가도 바로 <em>시간 초과</em>가 결렸다. 이유는 ArrayList의 경우 일반 배열과 달리 초반에 메모리 할당이 되지 않기 때문에 추가/삭제 시 메모리 할당을 매번 해줘야 한다. 따라서 일반적으로 일반 배열이 더욱 빠르다. 그래서 두번째 접근 방식으로 일반 배열을 사용하는 것을 택했다. 일반 배열을 사용하면 최소값을 찾는 등의 메소드를 사용하기는 어렵지만 최소값을 찾는 구현은 어렵지 않고, 시간 복잡도도 비슷하기 때문에 시도해 보았다.</p>

<p><strong>코드:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lastIndex</span><span class="o">){</span>
  <span class="kt">long</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">startIndex</span> <span class="o">==</span> <span class="n">lastIndex</span><span class="o">){</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">startIndex</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
    	<span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
  <span class="kt">long</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
  <span class="n">area</span> <span class="o">=</span> <span class="n">min</span><span class="o">*(</span><span class="n">lastIndex</span><span class="o">-</span><span class="n">startIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">startIndex</span> <span class="o">+</span> <span class="n">list</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">min</span><span class="o">);</span>
  <span class="k">if</span><span class="o">(</span><span class="n">area</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">startIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">lastIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
  <span class="k">else</span><span class="o">{</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="접근-방법-2-arrays">접근 방법 2: Arrays</h4>

<p>Array를 사용해서 최소값을 구하기</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. for-loop를 사용해서 최소값 구하기
2. 최소값 사용하여 넓이 구하기 
3. 접근 방법 1에서와 같이 재귀하기
</code></pre></div></div>

<p>ArrayList를 사용했을 때보다는 빨랐기 때문에 더 많은 test case를 통과할 수 있었다. 하지만 여전히 시간초과에 걸렸다.</p>

<p>문제에서 나온 직사각형의 갯수 제한은 100,000이고 재귀 초기함수가 <code class="highlighter-rouge">(startIndex==lastIndex)</code> 일 때이기 때문에 각각하나씩 모두 접근한다. 이때마다 해당 구간의 최소값을 찾기위해 O(n)만큼 탐색을 하니 시간 초과가 걸릴만 하다. 때문에 문제의 태그에서 나온 세그먼트 트리에 대해서 공부하고 활용해보기로 했다.</p>

<p><strong>코드:</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lastIndex</span><span class="o">){</span>
  <span class="kt">long</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kt">long</span> <span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="kt">long</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">startIndex</span><span class="o">==</span><span class="n">lastIndex</span><span class="o">){</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">startIndex</span><span class="o">];</span>
    <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
      <span class="n">max</span><span class="o">=</span><span class="n">area</span><span class="o">;</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">startIndex</span><span class="o">;</span><span class="n">temp</span><span class="o">&lt;=</span><span class="n">lastIndex</span><span class="o">;</span><span class="n">temp</span><span class="o">++){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">min</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">value</span><span class="o">[</span><span class="n">temp</span><span class="o">]&lt;</span><span class="n">min</span><span class="o">){</span>
      <span class="n">min</span> <span class="o">=</span> <span class="n">value</span><span class="o">[</span><span class="n">temp</span><span class="o">];</span>
      <span class="n">index</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="n">area</span> <span class="o">=</span> <span class="n">min</span><span class="o">*(</span><span class="n">lastIndex</span><span class="o">-</span><span class="n">startIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">area</span><span class="o">&gt;</span><span class="n">max</span><span class="o">)</span>
    <span class="n">max</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
  
  <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">startIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">lastIndex</span><span class="o">)</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
  <span class="k">else</span><span class="o">{</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">startIndex</span><span class="o">,</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">solve</span><span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">lastIndex</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="접근-방법-3-segment-tree">접근 방법 3: Segment Tree</h4>

<p>세그먼트 트리는 <mark>주어진 쿼리에 빠르게 응답하기 위해 만들어진 자료구조</mark>이고, 그 사용법은 쿼리마다 상이하다. 가장 대표적으로 세그먼트 트리를 사용할 때 내는 예시는 구간 합을 구하는 문제이다. 하지만 이 글에서는 <em>히스토그램에서 가장 큰 직사각형</em> 푸는 문제에 적용된 세그먼트를 설명할 것이다.</p>

<p>풀이에 세그먼트 트리를 활용할 수 있는 상황은 다음 두가지와 같다. <strong>1. 쿼리 형식으로 문제가 주어진 경우 2. 시간 복잡도를 log로 만들고 싶을 경우</strong>. <small>개인적으로 구간에 관련한 문제가 나올 경우, 시간 복잡도를 줄이기 위해 세그먼트 트리 사용을 하는 것이 좋은 것 같다.</small></p>

<p>세그먼트 트리는 주로 이진트리를 이용하며, 주로 완전 이진 트리 Full Binary Tree에 가깝다. 그렇기 대문에 세그먼트 트리를 사용하면 다음과 같은 성능을 지닌다.</p>

<ol>
  <li>쿼리의 결과값 구하기: O(lgN)</li>
  <li>값 업데이트 하기: O(lgN)</li>
</ol>

<p>히스토그램 문제에서는 쿼리의 결과값 구하는 과정의 시간 복잡도가 O(lgN)이 되면서 성능이 매우 좋아지게 된다.</p>

<h6 id="segment-tree-란">Segment Tree 란?</h6>

<p><img src="https://user-images.githubusercontent.com/63405904/109445201-6e4fe900-7a82-11eb-8e6c-09edb7e236a4.png" alt="histogram" /></p>

<p>히스토그램 문제에서는 위에서 말했듯 다음 두가지 풀이를 반복한다.</p>

<ol>
  <li>
    <p>최소값 기준으로 구간 나누기</p>
  </li>
  <li>
    <p>나뉘어진 구간에서 재귀로 1) 반복하기</p>
  </li>
</ol>

<p>히스토그램에서 중요 요소는 최소값이기 때문에 각 구간의 최소값의 위치를 저장하도록 한다. 따라서 이후에 특정 구간의 최소값을 찾을 때 <mark>O(lgN)</mark>만큼의 시간복잡도로 최소값을 찾을 수 있다. 위의 이진 세그먼트 트리는 10개의 원소가 있다고 가정했을 때 각 구간이 나뉜 것을 보여준다. <strong>세그먼트 트리에서 모든 leaf node는 원래 배열의 자기자신 element</strong>이다.</p>

<p>요약하자면 segment tree의 구성요소는 다음과 같다.</p>

<ul>
  <li>Leaf node :  원래 배열의 그 수의 위치. <small>(이 값은 응용 문제에 따라서 달라진다.)</small></li>
  <li>다른 node:  왼쪽 자식과 오른쪽 자식 중 더 최소값의 위치.</li>
</ul>

<p>히스토그램 문제에서 Segment tree 구현을 요약하면 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 초기화 함수: 구간이 자기 자신일 경우, leaf node이므로 해당 위치를 기록함. 
2. 재귀 함수: 구간을 반으로 나누어서 재귀함.
3. 일반 함수: 자신의 왼쪽 자식 노드와, 오른쪽 자식 노드 위치의 값을 비교하여 더 작은 값의 위치를 트리의 해당 노트에 입력함. 
</code></pre></div></div>

<p>전체 구간 <code class="highlighter-rouge">0 ~ n-1</code>까지부터 시작해 재귀를 하면 각 구간마다의 <mark>최솟값의 위치</mark>를 기록한 <em>lgN</em> 높이 만큼의 segment tree가 생성된다. 이 세그먼트 트리를 사용해서 더 빠른 방법으로 최소값을 탐색하고 제일 앞에서 설명한 방법을 통해서 정답을 도출하면 된다.</p>

<hr />

<p>다음 글에서 구체적으로 세그먼트 트리를 구현하는 방법과 히스토그램에서 응용된 방법에 대해서 다루도록 하겠다.</p>

<p><strong><small>[참고 자료]: https://www.acmicpc.net/blog/view/12, https://www.crocus.co.kr/648, https://www.acmicpc.net/blog/view/9 </small></strong></p>

	  ]]></description>
	</item>

	<item>
	  <title>[번역] Lower and Upper Bound Theory</title>
	  <link>//low-upper-bound</link>
	  <author></author>
	  <pubDate>2020-09-04T10:18:00+00:00</pubDate>
	  <guid>//low-upper-bound</guid>
	  <description><![CDATA[
	     <p>알고리즘에 대해서 배울 때 가장 먼저 다루는 부분이 바로 <strong>Time Complexity</strong> 이다. 기술이 발전하면서 메모리에 대한 부분은 상당 부분 해결이 되고 걱정하지 않아도 되는 부분이 되었다. 하지만 시간 복잡도 측면에서는 아무리 발전해도 부족한 부분이다. 왜냐하면 짧으면 짧을수록 더 좋기 때문이다. 따라서 알고리즘 강의를 들을 때에는 항상 Time Complexity에 대한 강의를 시작으로 배운다. 어떠한 문제에 대해서 여러가지 알고리즘을 사용하여 해결할 수 있을 때 무엇이 최적의 알고리즘인지를 판단하는 잣대는 해당 알고리즘으로 문제를 해결하는데 걸리는 시간이기 때문이다. 거기서 핵심적인 역할을 하는 두 theory에 대해서 <a href="https://www.geeksforgeeks.org/lower-and-upper-bound-theory/">다음 글</a>의 내용을 번역 및 정리하면서 알아보자.</p>

<hr />

<p>Lower Bound와 upper Bound Theory는 어떠한 문제에 대한 가장 적은 복잡도를 가진 알고리즘을 선택하는데 핵심적인 역할을 한다. 구체적으로 이 이론들을 다루기 이전에 각각 Lower Bound와 Upper Bound가 무엇을 의미하는지 살펴보자.</p>

<ul>
  <li>
    <p><strong>Lower Bound</strong> -</p>

    <p>L(n)이 알고리즘 A에 대한 수행 시간일 때, $L(n) &gt;= C*g(n)$을 성립하는 $C$가 있는 경우 $g(n)$은 A의 lower bound이다. 어떠한 알고리즘의 lower bound는 Big Omega 로 나타낸다.</p>
  </li>
  <li>
    <p><strong>Upper Bound</strong> -</p>

    <p>U(n)이 알고리즘 A에 대한 수행 시간일 때, $L(n) &lt;= C*g(n)$을 성립하는 $C$가 있는 경우 $g(n)$은 A의 lower bound이다. 어떠한 알고리즘의 lower bound는 Big Oh(O) 로 나타낸다.</p>
  </li>
</ul>

<h4 id="1-lower-bound-theory">1. Lower Bound Theory:</h4>

<p>Lower Bound Theory에 의하면 어떠한 알고리즘의 lower bound에 대하여 다른 어떠한 알고리즘도 랜덤한 input에 대하여 L(n)보다 적은 시간 복잡도를 가질 수 없다. 또한 다르게 말하면 모든 알고리즘들이 <strong>적어도 L(n)</strong> 만큼의 시간을 가질 수 밖에 없다.</p>

<p><em>주의할 점: L(n)은 모든 알고리즘 중 최소의 복잡도를 나타낸다.</em></p>

<p>Lower Bound 는 그 어던 알고리즘에 있어서도 매우 중요하다. Lower Bound를 계산한 후에, 특정 알고리즘의 복잡도를 계산하여 L(n)과 같다면 해당 알고리즘이 최적의 알고리즘이라는 것을 알 수 있다. 이 글에서 우리는 어떠한 알고리즘의 lower bound를 찾는 방법들에 대해서 다루어 볼 것이다.</p>

<p>명심해야 하는 것은 언제나 우리의 가장 중요한 목적이 <strong>최적의 알고리즘</strong>을 구하는 것이라는 것이다. 여기서 최적의 알고리즘이라고 함은 해당 알고리즘의 Upper Bound 가 해당 문제의 Lower Bound와 같은(U(n)=L(n)) 경우이다. <em>Merge sort</em>를 통해서 optimal algorithm을 살펴보자.</p>

<h5 id="trivial-lower-bound--">Trivial Lower Bound -</h5>

<p>Lower bound를 찾는 가장 쉬운 방법이다. 이 방법은 Lower bound가 문제의 input의 개수와 output의 개수로 쉽게 알 수 있다고 하는 Trivial Lower Bound 방법이다.</p>

<h6 id="예시-multiplication-of-nn-matrix">예시: Multiplication of n*n matrix</h6>

<ul>
  <li>Input: 2개의 행렬에 대해 $2n^2$개</li>
  <li>Output: 1 개의 n*n 행렬, $n^2$ 개</li>
</ul>

<p>위의 input/output의 숫자를 보면 쉽게 lower bound가 $O(n^2)$라는 것을 알 수 있다.</p>

<h5 id="computational-model--">Computational Model -</h5>

<p>이 방법을 비교를 하는 모든 알고리즘에 대해서 사용할 수 있다. 예를 들어, sorting 문제의 경우 각 원소들을 비교하고 배열을 해야한다. 탐색하는 문제 또한 비슷하다. 예시를 통해서 해당 문제들의 lower bound를 구하는 법에 대해서 살펴보자.</p>

<h5 id="ordered-searching--">Ordered Searching -</h5>

<p>이미 정렬이 되어 있는 리스트에 대해서 탐색을 하는 경우이다.</p>

<h6 id="example-1-linear-search">Example 1: Linear Search</h6>

<p>처음부터 시작하여 차례로 각 element를 순회하며 해당 원소가 찾던 원소인지 확인한다.</p>

<h6 id="example-2-binary-search">Example 2: Binary Search</h6>

<p>중간에 있는 것과 비교하여 찾고자 하는 숫자가 클 경우, 반의 오른쪽 부분을, 작을 경우 반의 왼쪽 부분을 나누어서 탐색한다.</p>

<h6 id="calculation-the-lower-bound">Calculation the lower bound:</h6>

<p>비교하는 최대 횟수는 n이고, 리스트의 tree에 총 k levels이 있다고 한다면..</p>

<ol>
  <li>Node의 갯수는 $2^k-1$</li>
  <li>$2^k -1$에 대하여 worst case의 경우 upper bound 개수인 n</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>각 레밸에서 1번 비교를 하니, 비교하는 횟수는 $k&gt;=</td>
          <td>log2n</td>
          <td>$</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<p>따라서 비교 문제에 있어서 n개의 원소를 가질 경우 복잡도는 log(n) 보다 작을 수 없다. 따라서 시간복잡도를 (log n)을 가진 binary serach가 최적화된 알고리즘이라고 판단할 수 있다.</p>

<h4 id="2-upper-bound-theory">2. Upper Bound Theory</h4>

<p>Upper Bound Theory는 해당 문제를 푸는데 최대 U(n)만큼이 시간이 뜬다는 것이다. 주로 worst case input인 경우 Upper Bound를 알 수 있다.</p>


	  ]]></description>
	</item>


</channel>
</rss>
